<p jlsfdskjfsd> this is really how it should be done</p>
<p 11111>
  This document will guide you through the process of Countly SDK installation.
</p>
<div class="callout callout--info">
  <h3 class="callout__title">Minimum Android version</h3>
  <p>
    Countly Android SDK needs a minimum of Android 2.3+ (API Level 9).
  </p>
</div>
<h1>Adding Countly SDK</h1>
<p>
  You can use both Android Studio and Eclipse to add Countly SDK to your project.
</p>
<p>
  <strong>Adding via Android Studio</strong>
</p>
<p>
  To download the SDK package you can use the default JCenter repository. If it's
  not included in your project, include it like this:
</p>
<pre><code class="text">buildscript {
    repositories {
        jcenter()
    }
}</code></pre>
<p>You can also add the Bintray Maven repository:</p>
<pre><code class="text">buildscript {
    repositories {
        maven {
            url  "http://dl.bintray.com/countly/maven"
        }
    }
}</code></pre>
<p>
  Now, add Countly SDK dependency (<strong>use latest SDK version from gradle, not the one below</strong>).
</p>
<pre><code class="text">dependencies {
		compile 'ly.count.android:sdk:19.02.3'
}</code></pre>
<p>
  <strong>Adding SDK via Eclipse</strong>
</p>
<p>
  Eclipse users can download JARs - <code>sdk.jar</code> or
  <code>sdk.jar &amp; sdk-messaging.jar</code> depending on whether you need Countly
  Push support or not
  <a href="https://github.com/Countly/countly-sdk-android/releases">from Github Releases</a>
  page.
</p>
<p>
  Another option for Eclipse users is to use sources instead of jars. To do that,
  just create 2 or 3 packages and put sources from
  <a href="http://github.com/Countly/countly-sdk-android">Github repository</a>
  into corresponding packages.
</p>
<div class="callout callout--info">
  <h3 class="callout__title">Generate personalized SDK code snippets</h3>
  <p>
    <a href="http://code.count.ly">Countly Code Generator</a> can be used to
    generate SDK custom code snippets easily and fast. You can provide values
    for your custom event, or user profile, or just start with basic integration
    and this service will generate necessary code for you to use in your favorite
    IDE (e.g Android Studio).
  </p>
</div>
<table>
  <tbody>
    <tr>
      <th>Component</th>
      <th>Package name</th>
      <th>Path at Github repo</th>
    </tr>
    <tr>
      <td>Countly SDK</td>
      <td>ly.count.android.sdk</td>
      <td>countly-sdk-android/sdk/src/main/java/ly/count/android/sdk</td>
    </tr>
    <tr>
      <td>OpenUDID</td>
      <td>org.openudid</td>
      <td>countly-sdk-android/sdk/src/main/java/org/openudid</td>
    </tr>
    <tr>
      <td>Countly Push SDK</td>
      <td>ly.count.android.sdk.messaging</td>
      <td>
        countly-sdk-android/sdk/src/main/java/ly/count/android/sdk/messaging
      </td>
    </tr>
  </tbody>
</table>
<h1>Setting up Countly SDK</h1>
<p>
  First, you'll need to decide which device ID generation strategy to use. There
  are several options defined below:
</p>
<p>
  First and easiest method is, if you want Countly SDK to take care of device ID
  seamlessly, use line below. Do not put a trailing "/" at the end of the server
  URL or it won't work. Starting from the version 16.12.03, the SDK will erase
  the trailing "/" and write a warning to the log.
</p>
<pre><code class="java">Countly.sharedInstance().init(this, "https://YOUR_SERVER", "YOUR_APP_KEY")</code></pre>
<div class="callout callout--info">
  <h3 class="callout__title">Which server/host should I use inside SDK?</h3>
  <p>
    If you are using Countly Enterprise Edition trial servers use
    <code>https://try.count.ly</code>, <code>https://us-try.count.ly</code> or
    <code>https://asia-try.count.ly</code>. Basically the domain you are accessing
    your trial dashboard from.
  </p>
  <p>
    If you use Community Edition and Enterprise Edition, use your own domain
    name or IP address like
    <a href="https://example.com">https://example.com</a> or
    <a href="https://IP">https://IP</a> (if SSL is setup).
  </p>
</div>
<p>
  Second, you can specify device ID by yourself if you have one (it has to be unique
  per device):
</p>
<pre><code class="java">Countly.sharedInstance().init(this, "https://YOUR_SERVER", "YOUR_APP_KEY", "YOUR_DEVICE_ID")</code></pre>
<p>
  Third, you can rely on Google Advertising ID for device ID generation.
</p>
<pre><code class="java">Countly.sharedInstance().init(this, "https://YOUR_SERVER", "YOUR_APP_KEY", null, DeviceId.Type.ADVERTISING_ID)</code></pre>
<p>Or, you can use OpenUDID:</p>
<pre><code class="java">Countly.sharedInstance().init(this, "https://YOUR_SERVER", "YOUR_APP_KEY", null, DeviceId.Type.OPEN_UDID)
</code></pre>
<p>
  For all of those different approaches,
  <code>Countly.sharedInstance().init(...)</code> method should be called from
  your <code>Application</code> subclass (preferred), or from your main activity
  <code>onCreate</code> method.
</p>
<p>
  In the case of OpenUDID you'll need to include following declaration into your
  <code>AndroidManifest.xml</code>:
</p>
<pre><code class="xml">&lt;service android:name="org.openudid.OpenUDID_service"&gt;
    &lt;intent-filter&gt;
        &lt;action android:name="org.openudid.GETUDID" /&gt;
    &lt;/intent-filter&gt;
&lt;/service&gt;
</code></pre>
<p>
  In the case of Google Advertising ID, please make sure that you have Google Play
  services 4.0+ included into your project. Also note that Advertising ID silently
  falls back to OpenUDID in case it failed to get Advertising ID when Google Play
  services are not available on a device.
</p>
<p>
  After <code>Countly.sharedInstance().init(...)</code> call you'll need to add
  following calls to all your activities:
</p>
<ul>
  <li>
    Call <code>Countly.sharedInstance().onStart(this)</code> in onStart, where
    <code>this</code> is a link to the current Activity.
  </li>
  <li>
    Call <code>Countly.sharedInstance().onStop()</code> in onStop.
  </li>
</ul>
<p>
  If the "onStart" and "onStop" calls are not added some functionality will not
  work, for example sessions will not be tracked. The countly "onStart" has to
  be called in the activities "onStart" function, it can not be called in "onCreate"
  or any other place otherwise the application will receive exceptions.
</p>
<div class="img-container">
  <img src="https://count.ly/images/guide/283f96f-activity_lifecycle.png">
</div>
<p>
  Additionally, make sure that <em>INTERNET</em> permission is set if there's none
  in your manifest file.
</p>
<h2>Enabling logging</h2>
<p>
  If logging is enabled then our sdk will print out debug messages about it's internal
  state and encountered problems.
</p>
<p>
  When advise doing this while implementing countly features in your application.
</p>
<pre><code class="java">Countly.sharedInstance().setLoggingEnabled(true);</code></pre>
<h2>Changing a device ID</h2>
<p>
  In case your application authenticates users, you can also change device ID to
  your user ID later. This helps you identify a specific user with a specific ID
  on a device she logs in, and the same scenario can also be used in cases this
  user logs in using a different way (e.g tablet, another mobile phone or web).
  In this case any data stored in Countly server database and associated with temporary
  device ID will be transferred into user profile with device id you specified
  in the following method call:
</p>
<pre><code class="java">Countly.sharedInstance().changeDeviceId("new device ID")</code></pre>
<p>
  Whenever your authenticated user logs out, in case you want to track history
  and further activity under another Countly user, call:
</p>
<pre><code class="java">Countly.sharedInstance().changeDeviceId(DeviceId.Type.OPEN_UDID, null)</code></pre>
<p>
  You can also set Advertising ID as your device ID generation strategy or even
  supply your own string with <code>DeviceId.Type.DEVELOPER_SPECIFIED</code> type.
</p>
<h2>Retrieving the device id and its type</h2>
<p>
  You may wanty to see what device id Countly is assigning for the specific device
  and what the source of that id is. For that you may use the following calls.
  The id type is an enum with the possible values of: "DEVELOPER_SUPPLIED", "OPEN_UDID",
  "ADVERTISING_ID".
</p>
<pre><code class="text">String usedId = Countly.sharedInstance().getDeviceID();
Type idType = Countly.sharedInstance().getDeviceIDType();</code></pre>
<h2>Forcing HTTP POST</h2>
<p>
  If the data sent to the server is short enough, the sdk will use HTTP GET requests.
  In case you want an override so that HTTP POST is used in all cases, call the
  "setHttpPostForced" function after you called "init". You can use the same function
  to later in the apps life cycle disable the override. This function has to be
  called every time the app starts.
</p>
<pre><code class="java">//the init call before the override
Countly.sharedInstance().init(this, "https://YOUR_SERVER", "YOUR_APP_KEY", "YOUR_DEVICE_ID")
  
//enabling the override
Countly.sharedInstance().setHttpPostForced(true);
  
//disabling the override
Countly.sharedInstance().setHttpPostForced(false);</code></pre>
<h2>Parameter Tampering Protection</h2>
<p>
  You can set optional <code>salt</code> to be used for calculating checksum of
  request data, which will be sent with each request using
  <code>&amp;checksum</code> field. You need to set exactly the same
  <code>salt</code> on Countly server. If <code>salt</code> on Countly server is
  set, all requests would be checked for validity of <code>&amp;checksum</code>
  field before being processed.
</p>
<pre><code class="java">Countly.sharedInstance().enableParameterTamperingProtection("salt");</code></pre>
<h3>Using Proguard</h3>
<p>
  Proguard obfuscates OpenUDID &amp; Countly Messaging classes. So if you use OpenUDID
  or Countly Messaging in your application, you need to add following lines to
  your Proguard rules file:
</p>
<pre><code class="java">-keep class org.openudid.** { *; }
-keep class ly.count.android.sdk.** { *; }</code></pre>
<p>
  <strong>Note:</strong> Make sure you use App Key (found under Management -&gt;
  Applications) and not API Key. Entering API Key will not work.
</p>
<h1>Setting up custom events</h1>
<p>
  A <a href="http://resources.count.ly/docs/custom-events">custom event</a> is
  any type of action that you can send to a Countly instance, e.g purchase, settings
  changed, view enabled and so. This way it's possible to get much more information
  from your application compared to what is sent from Android SDK to Countly instance
  by default.
</p>
<div class="callout callout--warning">
  <h3 class="callout__title">Data passed should be in UTF-8</h3>
  <p>
    All data passed to Countly server via SDK or API should be in UTF-8.
  </p>
</div>
<p>
  As an example, we will be recording a <strong>purchase</strong> event. Here is
  a quick summary what information each usage will provide us:
</p>
<ul>
  <li>
    Usage 1: how many times <strong>purchase</strong> event occured.
  </li>
  <li>
    Usage 2: how many times <strong>purchase</strong> event occured + the total
    amount of those purchases.
  </li>
  <li>
    Usage 3: how many times <strong>purchase</strong> event occured + which countries
    and application versions those purchases were made from.
  </li>
  <li>
    Usage 4: how many times <strong>purchase</strong> event occured + the total
    amount both of which are also available segmented into countries and application
    versions.
  </li>
  <li>
    Usage 5: how many times <strong>purchase</strong> event occured + the total
    amount both of which are also available segmented into countries and application
    versions + the total duration of those events.
  </li>
</ul>
<h2>1. Event key and count</h2>
<pre><code class="java">Countly.sharedInstance().recordEvent("purchase", 1);</code></pre>
<h2>2. Event key, count and sum</h2>
<pre><code class="java">Countly.sharedInstance().recordEvent("purchase", 1, 0.99);</code></pre>
<h2>3. Event key and count with segmentation(s)</h2>
<pre><code class="java">HashMap&lt;String, String&gt; segmentation = new HashMap&lt;String, String&gt;();
segmentation.put("country", "Germany");
segmentation.put("app_version", "1.0");

Countly.sharedInstance().recordEvent("purchase", segmentation, 1);</code></pre>
<h2>4. Event key, count and sum with segmentation(s)</h2>
<pre><code class="java">HashMap&lt;String, String&gt; segmentation = new HashMap&lt;String, String&gt;();
segmentation.put("country", "Germany");
segmentation.put("app_version", "1.0");

Countly.sharedInstance().recordEvent("purchase", segmentation, 1, 0.99);</code></pre>
<h2>5. Event key, count, sum and duration with segmentation(s)</h2>
<pre><code class="java">HashMap&lt;String, String&gt; segmentation = new HashMap&lt;String, String&gt;();
segmentation.put("country", "Germany");
segmentation.put("app_version", "1.0");

Countly.sharedInstance().recordEvent("purchase", segmentation, 1, 0.99, 60);</code></pre>
<p>
  Those are only a few examples with what you can do with custom events. You can
  extend those examples and use country, app_version, game_level, time_of_day and
  any other segmentation that will provide you valuable insights.
</p>
<h1>Timed events</h1>
<p>
  It's possible to create to create timed events by defining a start and stop moment.
</p>
<pre><code class="java">String eventName = "Custom event";

//start some event
Countly.sharedInstance().startEvent(eventName);
//wait some time

//end the event 
Countly.sharedInstance().endEvent(eventName);</code></pre>
<p>
  When ending a event you can also provide additional information. But in that
  case you have to provide segmentation, count and sum. The default values for
  those are "null", 1 and 0.
</p>
<pre><code class="java">String eventName = "Custom event";

//start some event
Countly.sharedInstance().startEvent(eventName);
//wait some time

Map&lt;String, String&gt; segmentation = new HashMap&lt;&gt;();
segmentation.put("wall", "orange");

//end the event while also providing segmentation information, count and sum
Countly.sharedInstance().endEvent(eventName, segmentation, 4, 34);
</code></pre>
<h1>User location</h1>
<p>
  While integrating this SDK into your application, you might want to track your
  user location. You could use this information to better know your apps user base
  or to send them tailored push notifications based on their coordinates. There
  are 4 fields that can be provided:
</p>
<ul>
  <li>country code in the 2 letter iso standard</li>
  <li>city name (has to be set together with country code)</li>
  <li>
    Comma separate latitude and longitude values, for example "56.42345,123.45325"
  </li>
  <li>ip address of your user</li>
</ul>
<pre><code class="java">//set user location
String countryCode = "us";
String city = "Houston";
String latitude = "29.634933";
String longitude = "-95.220255";
String ipAddress = null;

Countly.sharedInstance().setLocation(countryCode, city, latitude + "," + longitude, ipAddress);</code></pre>
<p>
  When those values are set, they will be sent every time when initiating a session.
  If they are set after a session was initiated, a separate request will also be
  sent. Except for ip address, because Countly Server processes ip address only
  when starting a session.
</p>
<p>If you don't want to set specific fields, set them to null.</p>
<p>
  Users might want to opt out of location tracking. To do that, call:
</p>
<pre><code class="java">//disable location
Countly.sharedInstance().disableLocation();</code></pre>
<p>
  It will erase cached location data from device and stop further tracking.
</p>
<p>
  If, after disabling location, "setLocation" is called with any non null value,
  tracking will resume.
</p>
<h1>Attribution analytics &amp; install campaigns</h1>
<p>
  <a href="https://count.ly/attribution-analytics">Countly Attribution Analytics</a>
  allows you to measure your marketing campaign performance by attributing installs
  from specific campaigns. This feature is available for Enterprise Edition.
</p>
<p>
  In order to get more precise attribution on Android it is highly recommended
  to allow Countly to listen to <strong>INSTALL_REFERRER</strong> intent and you
  can do that by adding following XML code to your
  <strong>AndroidManifest.xml</strong> file, inside <strong>application</strong>
  tag.
</p>
<pre><code class="xml">&lt;receiver android:name="ly.count.android.sdk.ReferrerReceiver" android:exported="true"&gt;
	&lt;intent-filter&gt;
		&lt;action android:name="com.android.vending.INSTALL_REFERRER" /&gt;
	&lt;/intent-filter&gt;
&lt;/receiver&gt;</code></pre>
<p>
  Note that modifying <strong>AndroidManifest.xml</strong> file is the only thing
  you would need to do, in order to start getting data from your campaigns via
  Attribution Analytics plugin.
</p>
<p>
  For more information about how to setup your campaigns, please
  <a href="http://resources.count.ly/docs/referral-analytics">see this documentation</a>.
</p>
<h1>Getting user feedback</h1>
<p>
  There are two ways of getting feedback from your users: Star rating dialog, feedback
  widget.
</p>
<p>
  Star rating dialog allows users to give feedback as a rating from 1 to 5. The
  feedback widget allows to get the same 1 to 5 rating and also a text comment.
</p>
<h2>Feedback widget</h2>
<p>
  Feedback widget shows a server configured widget to your user devices.
</p>
<div class="img-container">
  <img src="https://count.ly/images/guide/072bb00-t1.png">
</div>
<p>
  It's possible to configure any of the shown text fields and replace with a custom
  string of your choice.
</p>
<p>
  In addition to a 1 to 5 rating, it is possible for users to leave a text comment
  and also leave a email in case the user would want some contact from the app
  developer.
</p>
<p>
  Trying to show the rating widget is a single call, but underneath is a two step
  process. Before it is shown, the SDK tries to contact the server to get more
  information about the dialog. Therefore a network connection to it is needed.
</p>
<p>
  You can try to show the widget after you have initialized the SDK. To do that,
  you first have to get the widget ID from your server:
</p>
<div class="img-container">
  <img src="https://count.ly/images/guide/2dd58c6-t2.png">
</div>
<p>
  Using that you can call the function to show the widget popup:
</p>
<pre><code class="java">String widgetId = "xxxxx";
String closeButtonText = "Close";
Countly.sharedInstance().showFeedbackPopup(widgetId, closeButtonText, activity, new CountlyStarRating.FeedbackRatingCallback() {
  @Override
  public void callback(String error) {
    if(error != null){
      Toast.makeText(activity, "Encountered error while showing feedback dialog: [" + error + "]", Toast.LENGTH_LONG).show();
    }
  }
});</code></pre>
<h2>Star rating dialog</h2>
<p>
  Star rating integration provides a dialog for getting user's feedback about the
  application. It contains a title, simple message explaining what it is for, a
  1-to-5 star meter for getting users rating and a dismiss button in case the user
  does not want to give a rating.
</p>
<p>
  This star-rating has nothing to do with Google Play Store ratings and reviews.
  It is just for getting a brief feedback from users, to be displayed on the Countly
  dashboard. If the user dismisses star rating dialog without giving a rating,
  the event will not be recorded.
</p>
<p>
  Star-rating dialog's title, message and dismiss button text can be customized
  either through the init function or the <code>SetStarRatingDialogTexts</code>
  function. If you don't want to override one of those values, set it to "null".
</p>
<pre><code class="java">//set it through the init function
Countly.sharedInstance().init(context, serverURL, appKey, deviceID, idMode, starRatingLimit, starRatingCallback, "Custom title", "Custom message", "Custom dismiss button text");

//Use the designated function:
Countly.sharedInstance().setStarRatingDialogTexts(context, "Custom title", "Custom message", "Custom dismiss button text");
</code></pre>
<p>Star rating dialog can be displayed in 2 ways:</p>
<ul>
  <li>Manually, by developer</li>
  <li>Automatically, depending on session count</li>
</ul>
<p>
  In order to display the Star rating dialog manually, you must call the
  <code>ShowStarRating</code> function. Optionally, you can provide the callback
  functions. There is no limit on how many times star-rating dialog can be displayed
  manually.
</p>
<pre><code class="java">//show the star rating without a callback
Countly.sharedInstance().showStarRating(context, null);

//show the star rating with a callback
Countly.sharedInstance().showStarRating(context, callback)</code></pre>
<p>
  Star rating dialog will be displayed automatically when application's session
  count reaches the specified limit, once for each new version of the application.
  This session count limit can be specified on initial configuration or through
  the <code>SetAutomaticStarRatingSessionLimit</code> function. The default limit
  is 3. Once star rating dialog is displayed automatically, it will not be displayed
  again unless there is a new app version.
</p>
<p>
  To show the automatic star rating dialog you need to pass the activity context
  during init.
</p>
<pre><code class="java">//set the rating limit through the init function
int starRatingLimit = 5;
Countly.sharedInstance().init(context, serverURL, appKey, deviceID, idMode, starRatingLimit, starRatingCallback, starRatingTextTitle, starRatingTextMessage, starRatingTextDismiss);

//set it through the designated function
Countly.sharedInstance().starRatingLimit(context, 5);</code></pre>
<p>
  If you want to enable the automatic star rating functionality, use
  <code>SetIfStarRatingShownAutomatically</code> function. It is disabled by default.
</p>
<pre><code class="java">//enable automatic star rating
Countly.sharedInstance().setIfStarRatingShownAutomatically(true);

//disable automatic star rating
Countly.sharedInstance().setIfStarRatingShownAutomatically(false);</code></pre>
<p>
  If you want to have the star rating shown only once per app's lifetime and not
  for each new version, use the "SetStarRatingDisableAskingForEachAppVersion" function.
</p>
<pre><code class="java">//disable star rating for each new version
Countly.sharedInstance().setStarRatingDisableAskingForEachAppVersion(true);

//enable star rating for each new version
Countly.sharedInstance().setStarRatingDisableAskingForEachAppVersion(false);</code></pre>
<p>
  The star rating callback provides functions for two events.
  <code>OnRate</code> is called when the user chooses a rating.
  <code>OnDismiss</code> is called when the user clicks the back button, clicks
  outside the dialog or clicks the "Dismiss" button. The callback provided in the
  init function is used only when showing the automatic star rating. For the manual
  star rating only the provided callback will be used.
</p>
<pre><code class="java">CountlyStarRating.RatingCallback callback = new CountlyStarRating.RatingCallback() {
    @Override
    public void OnRate(int rating) {
    	//the user rated the app
    }

    @Override
    public void OnDismiss() {
    	//the star rating dialog was dismissed
    }
};</code></pre>
<h1>Remote Config</h1>
<p>
  Remote config allows you to modiffy how your app functions or looks by requesting
  key-value pairs from your Countly server. The returned values can be modiffied
  based on the user profile. For more details please see
  <a href="https://resources.count.ly/docs/remote-config">Remote Config documentation</a>.
</p>
<h2>Automatic Remote Config download</h2>
<p>
  There are two ways of acquiring remote config data, by automatic download or
  manual request. By default, automatic remote config is disabled and therefore
  without developer intervention no remote config values will be requested.
</p>
<p>
  Automatic value download happens when the SDK is initiated or when the device
  ID is changed. To enable it, you have to call
  <code>setRemoteConfigAutomaticDownload</code> before init. As a optional value
  you can provide a callback to be informed when the request is finished.
</p>
<pre><code class="java">Countly.sharedInstance().setRemoteConfigAutomaticDownload(true, new RemoteConfig.RemoteConfigCallback() {
            @Override
            public void callback(String error) {
                if(error == null) {
                    Toast.makeText(activity, "Automatic remote config download has completed", Toast.LENGTH_LONG).show();
                } else {
                    Toast.makeText(activity, "Automatic remote config download encountered a problem, " + error, Toast.LENGTH_LONG).show();
                }
            }
        });
Countly.sharedInstance().init(appC, COUNTLY_SERVER_URL, COUNTLY_APP_KEY);</code></pre>
<p>
  If the callback returns a non null value, then you can expect that the request
  failed and no values where updated.
</p>
<p>
  When doing a automatic update, all locally stored values are replaced with the
  ones received (all locally stored ones are deleted and in their place are put
  new ones). It is possible that a previously valid key returns no value after
  a update.
</p>
<h2>Manual Remote Config download</h2>
<p>
  There are three ways for manually requesting remote config update: * Manually
  updating everything * Manually updating specific keys * Manually updating everything
  except specific keys
</p>
<p>
  Each of these requests also has a callback. If that returns a non null value,
  the request encountered some error and failed.
</p>
<p>
  Functionally the manual update for everything <code>remoteConfigUpdate</code>
  is the same as the automatic update - replaces all stored values with the ones
  from the server (all locally stored ones are deleted and in their place are put
  new ones). The advantage is that you can make the request whenever it is desirable
  for you. It has a callback to let you know when it has finished.
</p>
<pre><code class="java">Countly.sharedInstance().remoteConfigUpdate(new RemoteConfig.RemoteConfigCallback() {
            @Override
            public void callback(String error) {
                if(error == null) {
                    Toast.makeText(activity, "Update finished", Toast.LENGTH_SHORT).show();
                } else {
                    Toast.makeText(activity, "Error: " + error, Toast.LENGTH_SHORT).show();
                }
            }
        });</code></pre>
<p>
  You might want to update only specific key values. For that you need to call
  <code>updateRemoteConfigForKeysOnly</code> with a list of keys you want to be
  updated. That list is a array with string values of those keys. It has a callback
  to let you know when the request has finished.
</p>
<pre><code class="java">Countly.sharedInstance().updateRemoteConfigForKeysOnly(new String[]{"aa", "dd"}, new RemoteConfig.RemoteConfigCallback() {
            @Override
            public void callback(String error) {
                if(error == null) {
                    Toast.makeText(activity, "Update with inclusion finished", Toast.LENGTH_SHORT).show();
                } else {
                    Toast.makeText(activity, "Error: " + error, Toast.LENGTH_SHORT).show();
                }
            }
        });</code></pre>
<p>
  You might want to update all values except a few defined keys, for that call
  <code>updateRemoteConfigExceptKeys</code>. The key list is a array with string
  values of the keys. It has a callback to let you know when the request has finished.
</p>
<pre><code class="java">Countly.sharedInstance().updateRemoteConfigExceptKeys(new String[]{"aa", "dd"}, new RemoteConfig.RemoteConfigCallback() {
            @Override
            public void callback(String error) {
                if (error == null) {
                    Toast.makeText(activity, "Update with exclusion finished", Toast.LENGTH_SHORT).show();
                } else {
                    Toast.makeText(activity, "Error: " + error, Toast.LENGTH_SHORT).show();
                }
            }
        });</code></pre>
<p>
  When making requests with a "inclusion" or "exclusion" array, if those arrays
  ar empty or null, they will function the same as a simple manual request and
  will update all values. This means that it will also erase all keys not returned
  by the server.
</p>
<h2>Getting Remote Config values</h2>
<p>
  To request a stored value, call <code>getRemoteConfigValueForKey</code> with
  the specified key. If it returns <code>null</code> then no value was found. The
  SDK has no knowledge of the returned value type and therefore returns a
  <code>Object</code>. The developer needs to cast it to the appropiate type. The
  returned values can also be a <code>JSONArray</code>, <code>JSONObject</code>
  or just a simple value like <code>int</code>.
</p>
<pre><code class="java">Object value_1 = Countly.sharedInstance().getRemoteConfigValueForKey("aa");
Object value_2 = Countly.sharedInstance().getRemoteConfigValueForKey("bb");
Object value_3 = Countly.sharedInstance().getRemoteConfigValueForKey("cc");
Object value_4 = Countly.sharedInstance().getRemoteConfigValueForKey("dd");

int int_value = (int) value_1;
double double_value = (double) value_2;
JSONArray jArray = (JSONArray) value_3;
JSONObject jobj = (JSONObject) value_4;</code></pre>
<h2>Clearing Stored Remote Config values</h2>
<p>
  At some point you might want to erase all values downloaded from the server.
  To achieve that you need to call one function.
</p>
<pre><code class="java">Countly.sharedInstance().remoteConfigClearValues();</code></pre>
<h1>Setting up User Profiles</h1>
<p>
  Available with Enterprise Edition, User Profiles is a tool which helps you identify
  users, their devices, event timeline and application crash information. User
  Profiles can contain any information that either you collect, or is collected
  automatically by Countly SDK.
</p>
<p>
  You can send user related information to Countly and let Countly dashboard show
  and segment this data. You may also send a notification to a group of users.
  For more information about User Profiles, see
  <a href="http://resources.count.ly/docs/user-profiles">this documentation</a>.
</p>
<p>
  To provide information about the current user, you must call the
  <code>Countly.userData.setUserData</code> function. You can call it by providing
  a bundle of only the predefined fields or call it while also providing a second
  bundle of fields with your custom keys. After you have provided user profile
  information, you must save it by calling <code>Countly.userData.save()</code>.
</p>
<pre><code class="java">//Update the user profile using only predefined fields
Map&lt;String, String&gt; predefinedFields = new HashMap&lt;&gt;();
Countly.userData.setUserData(predefinedFields);
Countly.userData.save()


//Update the user profile using predefined and custom fields
Map&lt;String, String&gt; predefinedFields = new HashMap&lt;&gt;();
Map&lt;String, String&gt; customFields = new HashMap&lt;&gt;();
Countly.userData.setUserData(predefinedFields, customFields);
Countly.userData.save()</code></pre>
<p>The keys for predefined user data fields are as follows:</p>
<table>
  <tbody>
    <tr>
      <th>Key</th>
      <th>Type</th>
      <th>Description</th>
    </tr>
    <tr>
      <td>name</td>
      <td>String</td>
      <td>User's full name</td>
    </tr>
    <tr>
      <td>username</td>
      <td>String</td>
      <td>User's nickname</td>
    </tr>
    <tr>
      <td>email</td>
      <td>String</td>
      <td>User's email address</td>
    </tr>
    <tr>
      <td>organization</td>
      <td>String</td>
      <td>User's organisation name</td>
    </tr>
    <tr>
      <td>phone</td>
      <td>String</td>
      <td>User's phone number</td>
    </tr>
    <tr>
      <td>picture</td>
      <td>String</td>
      <td>URL to avatar or profile picture of the user</td>
    </tr>
    <tr>
      <td>picturePath</td>
      <td>String</td>
      <td>Local path to user's avatar or profile picture</td>
    </tr>
    <tr>
      <td>gender</td>
      <td>String</td>
      <td>User's gender as M for male and F for female</td>
    </tr>
    <tr>
      <td>byear</td>
      <td>String</td>
      <td>User's year of birth as integer</td>
    </tr>
  </tbody>
</table>
<p>
  Using "" for strings or a negative number for 'byear' will effectively delete
  that property.
</p>
<p>
  For custom user properties you may use any key values to be stored and displayed
  on your Countly backend.
  <strong>Note: keys with . or $ symbols will have those symbols removed.</strong>
</p>
<h2>Modifying custom data</h2>
<p>
  Additionally you can do different manipulations on your custom data values, like
  increment current value on server or store a array of values under the same property.
</p>
<p>Below is the list of available methods:</p>
<pre><code class="java">//set one custom properties
Countly.userData.setProperty("test", "test");
//increment used value by 1
Countly.userData.increment("used");
//increment used value by provided value
Countly.userData.incrementBy("used", 2);
//multiply value by provided value
Countly.userData.multiply("used", 3);
//save maximal value
Countly.userData.saveMax("highscore", 300);
//save minimal value
Countly.userData.saveMin("best_time",60);
//set value if it does not exist
Countly.userData.setOnce("tag", "test");
//insert value to array of unique values
Countly.userData.pushUniqueValue("type", "morning");
//insert value to array which can have duplocates
Countly.userData.pushValue("type", "morning");
//remove value from array
Countly.userData.pullValue("type", "morning");

//send provided values to server
Countly.userData.save();</code></pre>
<p>
  In the end always call <strong>Countly.userData.save()</strong> to send them
  to the server.
</p>
<h1>User Consent management</h1>
<div class="callout callout--warning">
  <h3 class="callout__title">This feature is available from 18.04</h3>
</div>
<p>
  To be compliant with GDPR, starting from 18.04, Countly provides ways to toggle
  different Countly features on/off depending on the given consent.
</p>
<p>
  More information about GDPR can be found
  <a href="https://blog.count.ly/countly-the-gdpr-how-worlds-leading-mobile-and-web-analytics-platform-can-help-organizations-5015042fab27">here</a>.
</p>
<p>
  By default the requirement for consent is disabled. To enable it, you have to
  call <code>setRequiresConsent</code> with <code>true</code>, before initializing
  Countly.
</p>
<pre><code class="java">Countly.sharedInstance().setRequiresConsent(true);
Countly.sharedInstance().init(appC, COUNTLY_SERVER_URL, COUNTLY_APP_KEY);</code></pre>
<p>
  By default no consent is given. That means that if no consent is enabled, Countly
  will not work and no network requests, related to features, will be sent. When
  consent status of a feature is changed, that change will be sent to the Countly
  server.
</p>
<p>
  For all features, except <code>push</code>, consent is not persistent and will
  have to be set every time before countly init. Therefore the storage and persistance
  of given consent falls on the sdk integrator.
</p>
<p>
  Consent for features can be given and revoked at any time, but if it is given
  after Countly init, some features might work partially.
</p>
<p>
  If consent is removed, but the appropriate function can't be called before the
  app closes, it should be done at next app start so that any relevant server side
  features could be disabled (like reverse geo ip for location)
</p>
<p>
  Feature names in the Android SDK are stored as static fields in the class called
  <code>CountlyFeatureNames</code>.
</p>
<p>
  The current features are: * <code>sessions</code> - tracking when, how often
  and how long users use your app * <code>events</code> - allow sending custom
  events to server * <code>views</code> - allow tracking which views user visits
  * <code>location</code> - allow sending location information *
  <code>crashes</code> - allow tracking crashes, exceptions and errors *
  <code>attribution</code> - allow tracking from which campaign did user come *
  <code>users</code> - allow collecting/providing user information, including custom
  properties * <code>push</code> - allow push notifications *
  <code>starRating</code> - allow to send their rating and feedback
</p>
<h2>Feature groups</h2>
<p>
  Features can be grouped into groups. With this you can give/remove consent to
  multiple features in the same call. They can be created using
  <code>createFeatureGroup</code>. Those groups are not persistent and have to
  be created on every restart.
</p>
<pre><code class="text">// prepare features that should be added to the group
String[] groupFeatures = new String[]{ Countly.CountlyFeatureNames.sessions, Countly.CountlyFeatureNames.location };

// create the feature group
Countly.sharedInstance().createFeatureGroup("groupName", groupFeatures);</code></pre>
<h2>Changing consent</h2>
<p>
  There are 3 ways of changing feature consent: * <code>giveConsent</code>/<code>removeConsent</code>
  - gives or removes consent to a specific feature
</p>
<pre><code class="text">// give consent to "sessions" feature
Countly.sharedInstance().giveConsent(new String[]{Countly.CountlyFeatureNames.sessions});

// remove consent from "sessions" feature
Countly.sharedInstance().removeConsent(new String[]{Countly.CountlyFeatureNames.sessions});</code></pre>
<ul>
  <li>
    <code>setConsent</code> - set consent to a specific (true/false) value
  </li>
</ul>
<pre><code class="text">// give consent to "sessions" feature
Countly.sharedInstance().setConsent(new String[]{Countly.CountlyFeatureNames.sessions}, true);

// remove consent from "sessions" feature
Countly.sharedInstance().setConsent(new String[]{Countly.CountlyFeatureNames.sessions}, false);</code></pre>
<ul>
  <li>
    <code>setConsentFeatureGroup</code> - set consent for a feature group to
    a specific (true/false) value
  </li>
</ul>
<pre><code class="text">// prepare features that should be added to the group
String[] groupFeatures = new String[]{ Countly.CountlyFeatureNames.sessions, Countly.CountlyFeatureNames.location };

String groupName = "featureGroup1";

// give consent to "sessions" feature
Countly.sharedInstance().setConsentFeatureGroup(groupName, true);

// remove consent from "sessions" feature
Countly.sharedInstance().setConsentFeatureGroup(groupName, false);</code></pre>
<h1>Setting up push notifications</h1>
<div class="callout callout--danger">
  <h3 class="callout__title">
    Read this important notice before integrating push notifications
  </h3>
  <p>
    In order to use push notifications for Android, you'll need to include a
    different version of SDK into your project. We have 3 library projects in
    Maven, Jcenter and Github: <code>sdk</code>, <code>sdk-messaging</code> &amp;
    <code>sdk-messaging-fcm</code> for no push integration needed, GCM integration
    &amp; FCM integration respectively. If you want messaging support, include
    second one (it also adds a dependency on "play-services-gcm") or third one
    (you'll need to add Firebase to your dependencies yourself).
  </p>
</div>
<p>
  Countly SDK versions prior to 18.04 supported only GCM notifications, while version
  18.04 implements both: GCM (<code>sdk-messaging</code> dependency) and FCM integration
  (<code>sdk-messaging-fcm</code> dependency). We recommend switching to FCM as
  soon as possible. Migration is seamless since old GCM users will continue to
  receive your notifications even after you update SDK &amp; server key.
</p>
<p>
  To upgrade SDK from GCM to FCM, you'll need to follow these steps:
</p>
<ul>
  <li>Migrate your GCM project to Firebase if not done yet.</li>
  <li>
    Remove old GCM server key from Countly dashboard (Applications -&gt; Management)
    and add FCM server key.
  </li>
  <li>
    Update your app by including
    <a href="https://firebase.google.com/docs/android/setup">Firebase SDK into it</a>.
  </li>
  <li>
    Remove <code>sdk-messaging</code> dependency from your app and add
    <code>sdk-messaging-fcm</code> one.
  </li>
</ul>
<h2>Getting GCM / FCM credentials</h2>
<p>
  Countly needs server key to authenticate with GCM or FCM. In case your app is
  still not migrated to Firebase, please do that.
</p>
<p>
  Then open <a href="https://console.firebase.google.com">Firebase console</a>
  and open Project settings:
</p>
<div class="img-container">
  <img src="https://count.ly/images/guide/57c5e32-Screenshot_2018-04-21_17.20.16.png">
</div>
<p>Select Cloud Messaging tab</p>
<div class="img-container">
  <img src="https://count.ly/images/guide/fb244d1-Screenshot-2018-04-21-17.20.41-x.png">
</div>
<p>
  Copy &amp; paste either GCM key (deprecated), or FCM key (only SDK 18.04+) into
  your application GCM/FCM credentials upload form in Countly dashboard, hit Validate
  and eventually save changes. For GCM (deprecated) you'll also need Sender ID
  to pass into <code>initMessaging</code> SDK call.
</p>
<div class="img-container">
  <img src="https://count.ly/images/guide/703de0a-Screenshot-2018-04-21-17.30.59-x.png">
</div>
<h2>FCM integration (recommended)</h2>
<p>
  Please check our
  <a href="https://github.com/Countly/countly-sdk-android/tree/master/app-messaging-fcm">Demo app</a>
  for a complete integration example.
</p>
<p>
  Once you followed Google guide for
  <a href="https://firebase.google.com/docs/android/setup">Adding Firebase to your project</a>,
  setting up Countly FCM is quite easy.
</p>
<p>
  <strong>Adding dependencies</strong>
</p>
<p>
  At first, add required dependencies to your <code>build.gradle</code>: (<strong>use latest SDK version below</strong>).
</p>
<pre><code class="java">implementation 'ly.count.android:sdk-messaging-fcm:19.02.3'
implementation 'com.google.firebase:firebase-messaging:12.0.1'</code></pre>
<p>
  Then add <code>CountlyPush.init()</code> call to your <code>Application</code>
  subclass or main activity <code>onCreate()</code>. Here we use
  <code>Application</code> subclass called <code>App</code>. Don't forget that
  Android O and later require use of <code>NotificationChannel</code>s. Use
  <code>CountlyPush.CHANNEL_ID</code> for Countly-displayed notifications:
</p>
<pre><code class="java">public class App extends Application {

    @Override
    public void onCreate() {
        super.onCreate();

        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {

            // Register the channel with the system; you can't change the importance
            // or other notification behaviors after this
            NotificationManager notificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);
            if (notificationManager != null) {
                // Create the NotificationChannel
                NotificationChannel channel = new NotificationChannel(CountlyPush.CHANNEL_ID, getString(R.string.countly_hannel_name), NotificationManager.IMPORTANCE_DEFAULT);
                channel.setDescription(getString(R.string.countly_channel_description));
                notificationManager.createNotificationChannel(channel);
            }
        }

        Countly.sharedInstance()
                .setLoggingEnabled(true)
                .init(this, "http://try.count.ly", "APP_KEY");

        CountlyPush.init(this, Countly.CountlyMessagingMode.PRODUCTION);

        FirebaseInstanceId.getInstance().getInstanceId()
                .addOnCompleteListener(new OnCompleteListener&lt;InstanceIdResult&gt;() {
                    @Override
                    public void onComplete(@NonNull Task&lt;InstanceIdResult&gt; task) {
                        if (!task.isSuccessful()) {
                            Log.w(TAG, "getInstanceId failed", task.getException());
                            return;
                        }

                        // Get new Instance ID token
                        String token = task.getResult().getToken();
                        CountlyPush.onTokenRefresh(token);
                    }
                });
    }
}</code></pre>
<p>
  Please note that in <code>CountlyPush.init()</code> you also specify mode of
  your token - test or production. It's quite handy to separate test devices from
  production ones by changing <code>CountlyMessagingMode</code> so you could test
  notifications before sending to all users.
</p>
<p>
  Now we need to add the <code>Service</code>. Add a service definition to your
  <code>AndroidManifest.xml</code>:
</p>
<pre><code class="xml">&lt;service android:name=".DemoFirebaseMessagingService"&gt;
    &lt;intent-filter&gt;
        &lt;action android:name="com.google.firebase.MESSAGING_EVENT" /&gt;
    &lt;/intent-filter&gt;
&lt;/service&gt;
</code></pre>
<p>... and a class for it:</p>
<pre><code class="java">public class DemoFirebaseMessagingService extends FirebaseMessagingService {
    private static final String TAG = "DemoMessagingService";

    @Override
    public void onNewToken(String token) {
        super.onNewToken(token);

        Log.d("DemoFirebaseService", "got new token: " + token);
        CountlyPush.onTokenRefresh(token);
    }

    @Override
    public void onMessageReceived(RemoteMessage remoteMessage) {
        super.onMessageReceived(remoteMessage);

        Log.d("DemoFirebaseService", "got new message: " + remoteMessage.getData());

        // decode message data and extract meaningful information from it: title, body, badge, etc.
        CountlyPush.Message message = CountlyPush.decodeMessage(remoteMessage.getData());

        if (message != null &amp;&amp; message.has("typ")) {
            // custom handling only for messages with specific "typ" keys
            message.recordAction(getApplicationContext());
            return;
        }

        Intent notificationIntent = null;
        if (message.has("anotherActivity")) {
            notificationIntent = new Intent(getApplicationContext(), AnotherActivity.class);
        }
      
        Boolean result = CountlyPush.displayMessage(getApplicationContext(), message, R.drawable.ic_message, notificationIntent);
        if (result == null) {
            Log.i(TAG, "Message wasn't sent from Countly server, so it cannot be handled by Countly SDK");
        } else if (result) {
            Log.i(TAG, "Message was handled by Countly SDK");
        } else {
            Log.i(TAG, "Message wasn't handled by Countly SDK because API level is too low for Notification support or because currentActivity is null (not enough lifecycle method calls)");
        }
    }

    @Override
    public void onDeletedMessages() {
        super.onDeletedMessages();
    }
}</code></pre>
<p>
  This class is responsible for token changes and message handling logic. Countly
  provides default UI for your notifications which would display a
  <code>Notification</code> if your app is in background or <code>Dialog</code>
  if it's active. It will also automatically report button clicks back to the server
  for Actioned metric conversion tracking. But using it or not is completely up
  to you. Let's have an overview of <code>onMessageReceived</code> method:
</p>
<ol>
  <li>
    It calls <code>CountlyPush.decodeMessage()</code> to decode message from
    Countly-specific format. This way you'll have way to access standard fields
    like badge, url or your custom data keys.
  </li>
  <li>
    Then it checks if message has <code>typ</code> custom data key and if it
    does, just records Actioned metric. Let's assume it's your custom notification
    to preload some data from remote server. Our demo app has a more in-depth
    scenario for this case.
  </li>
  <li>
    In case message also has <code>anotherActivity</code> custom data key, it
    creates a <code>notificationIntent</code> to launch activity named
    <code>AnotherActivity</code>. This intent is only used as default content
    intent for user tap on a <code>Notification</code>. For <code>Dialog</code>
    case it's not used.
  </li>
  <li>
    Then the service calls <code>CountlyPush.displayMessage()</code> to perform
    standard Countly notification displaying logic - <code>Notification</code>
    if your app is in background or not running and <code>Dialog</code> if it's
    in foreground. Note that this method takes an <code>int</code> resource parameter.
    It must be a compatible with corresponding version of Android notification
    small icon.
  </li>
</ol>
<p>
  Apart from listed above, SDK also exposes methods
  <code>CountlyPush.displayNotification()</code> &amp;
  <code>CountlyPush.displayDialog()</code> in case you only need
  <code>Notification</code>s and don't want <code>Dialog</code> or vice versa.
</p>
<p>Example push notification payload sent from Countly server:</p>
<pre><code class="json">{
	collapse_key: “collapse_key”, // if present
	time_to_live: 123,
	data: {
		message: “message string”, // if present
		title: “title string”, // if present
		sound: “sound string”, // if present
		badge: 123, // if present
		c.i: “message id string”,
		c.l: “http://message-wide-url”, // if present
		c.m: “http://rich.media.url.jpg”, // if present
		c.s: “true”, // if sound &amp; message absent
		c.b: [ // if present
			{t: “Button 1 title”, l: “http://button.1.url”},
			{t: “Button 2 title”, l: “http://button.2.url”} // if present
		],
		// any other data properties if present
	}
}
</code></pre>
<h2>Legacy GCM integration (deprecated)</h2>
<p>
  For GCM integration (<code>sdk-messaging</code> dependency) you'll need Sender
  ID. You can get one either from Firebase console (see above), or, in case you
  haven't yet migrated to Firebase, from
  <a href="https://console.developers.google.com">Google Developers Console</a>.
  Project Number below is your Sender ID. Note that this is different from the
  Project ID.
</p>
<div class="img-container">
  <img src="https://count.ly/images/guide/Ezz48oq7QYFeZufapg4n_3.png">
</div>
<p>
  Check that GCM (Google Cloud Messaging) service is enabled for your application:
</p>
<div class="img-container">
  <img src="https://count.ly/images/guide/AJQ3dYMsRY2lFhfcCEo2_2.png">
</div>
<p>
  As the final step, get a server token from Credentials menu of APIs &amp; auth
  section:
</p>
<div class="img-container">
  <img src="https://count.ly/images/guide/G6ce5Mj1RViEEiWwodI5_1.png">
</div>
<p>
  Make sure you don't enter any IP address restrictions or make sure those restrictions
  you've entered play nice with your Countly server.
</p>
<p>
  <strong>Add extra lines in <code>AndroidManifest.xml</code></strong>
</p>
<p>
  Make sure your application requests these permissions (replace
  <code>ly.count.android.demo.messaging</code> with your app package) in the apps
  manifest file, as shown below:
</p>
<pre><code class="xml">&lt;permission android:name="ly.count.android.demo.messaging.permission.C2D_MESSAGE" android:protectionLevel="signature" /&gt;
&lt;uses-permission android:name="ly.count.android.demo.messaging.permission.C2D_MESSAGE" /&gt;
</code></pre>
<p>
  Note that we use Advertising ID for device ID generation purposes in this example.
  If you want OpenUDID or have your own unique device ID, refer to
  <a href="Countly Android SDK">http://github.com/Countly/countly-sdk-android</a>
  documentation for details.
</p>
<p>
  And then, change the way you init Countly by adding an additional call to
  <code>initMessaging</code>:
</p>
<pre><code class="java">Countly.sharedInstance()
    .init(this, "YOUR_SERVER", "APP_KEY", null, DeviceId.Type.ADVERTISING_ID)
    .initMessaging(this, YourActivity.class, "PROJECT_NUMBER", Countly.CountlyMessagingMode.TEST);
</code></pre>
<p>
  Here, starting with line <code>.initMessaging</code>, first parameter is an activity
  which would be started when user clicks on notification, second parameter is
  its class, and <code>PROJECT_NUMBER</code> is Project Number retrieved from your
  Google Developers Console. Last parameter controls whether this device is recorded
  as a test device on Countly server, or as a production device. This would allow
  you to send messages either to test (using <code>.TEST</code>), or to production
  (using <code>.PRODUCTION</code>) users only, so you could separate user bases
  in order to make initial tests.
</p>
<p>
  Behind the scenes, Countly will add latest Google Play Services dependency and
  add some configuration options to your <code>AndroidManifest.xml</code> during
  manifest merging by gradle. See <code>sdk-messaging</code>'s
  <a href="https://github.com/Countly/countly-sdk-android/blob/master/sdk-messaging/build.gradle">build.gradle</a>
  and
  <a href="https://github.com/Countly/countly-sdk-android/blob/master/sdk-messaging/src/main/AndroidManifest.xml">AndroidManifest.xml</a>
  for details.
</p>
<p>
  If you want to get notified whenever new message arrives (optional step), register
  your <code>BroadcastReceiver</code> like this:
</p>
<pre><code class="java">@Override
protected void onResume() {
    super.onResume();

    /** Register for broadcast action if you need to be notified when Countly message received */
    messageReceiver = new BroadcastReceiver() {
        @Override
        public void onReceive(Context context, Intent intent) {
            Message message = intent.getParcelableExtra(CountlyMessaging.BROADCAST_RECEIVER_ACTION_MESSAGE);
            Log.i("CountlyActivity", "Got a message with data: " + message.getData());
        }
    };
    IntentFilter filter = new IntentFilter();
    filter.addAction(CountlyMessaging.getBroadcastAction(getApplicationContext()));
    registerReceiver(messageReceiver, filter);
}

@Override
protected void onPause() {
    super.onPause();

    /** Don't forget to unregister receiver */
    unregisterReceiver(messageReceiver);
}</code></pre>
<p>
  <strong>Automatic message handling</strong>
</p>
<p>
  Countly handles most common message handling tasks for you. For example, it generates
  and shows <code>Notification</code>s or <code>Dialog</code>s and tracks conversion
  rates automatically. In most cases you don't need to know how it works, but if
  you want to customize the behavior or exchange it with your own implementation,
  here is a more in depth explanation of what it does:
</p>
<p>
  First the received notification payload is analyzed and if it's a Countly notification
  (has <code>"c"</code> dictionary in payload), processes it. Otherwise, or if
  the notification analysis says that is a <code>Data-only</code> notification
  (you're responsible for message processing), it does nothing.
</p>
<p>
  After that it automatically makes callbacks to Countly Messaging server to calculate
  number of push notifications open and number of notifications with positive reactions.
</p>
<p>
  Here are explanations of common usage scenarios that are handled automatically:
  * Doesn't do anything except for conversions tracking if you specify that it
  is a <code>Data-only</code> notification in the dashboard. This effectively sets
  a special flag in message payload so you could process it on your own. * It displays
  a <code>Notification</code> whenever a message arrives and your application is
  in background. * It displays a <code>Dialog</code> when a new message arrives
  and your application is in foreground. * It displays a <code>Dialog</code> when
  a new message with a action arrives (open URL), and user responds to it by swiping
  or tapping notification.
</p>
<p>
  A <code>Dialog</code> always has a message, but the buttons set displayed depends
  on the message type:
</p>
<ul>
  <li>
    For notifications without any actions (just a text message) it displays a
    single Cancel button.
  </li>
  <li>
    For notifications with a <strong>URL</strong> (you ask user to open a link
    to some blog post, for instance) it displays Cancel &amp; Open buttons.
  </li>
  <li>
    For notifications with custom buttons it displays corresponding buttons.
  </li>
</ul>
<p>
  <strong>Using Android deep links</strong>
</p>
<p>
  When using Countly push notifications, you can benefit from Android deep links
  in your application for the buttons you provide. Those are basically links for
  specific activities of your application. A link can either be generic http link
  like <code>http://www.oneexample.com/survey</code> or a link with a custom URI
  (uniform resource indicator) scheme like <code>otherexample://things</code>.
</p>
<p>
  In order for Android deep links to work, you need to specify intent filters in
  your application's manifest for specific groups of links you want to use.
</p>
<p>
  A deeper guide on how to configure your application to use deep links can be
  found
  <a href="https://developer.android.com/training/app-links/deep-linking.html">here</a>.
</p>
<p>
  <strong>Developer-overridden message handling</strong>
</p>
<p>
  You can also completely disable push notification handling made by Countly SDK.
  To do that just add <code>true</code> to the end of your
  <code>initMessaging()</code> call:
</p>
<pre><code class="java">Countly.sharedInstance()
    .init(this, "YOUR_SERVER", "APP_KEY", null, DeviceId.Type.ADVERTISING_ID)
    .initMessaging(this, CountlyActivity.class, "PROJECT_NUMBER", Countly.CountlyMessagingMode.TEST, true);

</code></pre>
<p>
  This parameter effectively disables any UI interactions and
  <code>Activity</code> instantiation from Countly SDK. To enable custom processing
  of push notifications you can either register your own
  <code>WakefulBroadcastReceiver</code>, or use
  <a href="http://resources.count.ly/v1.0/docs/countly-sdk-for-android#section-integrating-push-notifications-into-android-application">our example with broadcast action</a>.
  Once you switched off default push notification UI, please make sure to call
  <code>CountlyMessaging.recordMessageOpen(id)</code> whenever push notification
  is delivered to your device and
  <code>CountlyMessaging.recordMessageAction(id, index)</code> whenever user positively
  reacted on your notification. <code>id</code> is a message id string you can
  get from <code>c.i</code> key of push notification payload. <code>index</code>
  is optional and used to identify type of action: 0 for tap on notification in
  drawer, 1 for first button of rich push, 2 for second one.
</p>
<p>
  <strong>Handling button or push clicks</strong>
</p>
<p>
  When receiving a push notification, the user can click directly on it, or a button
  it has. When user clicks on anywhere in the push notification, an intent is launched
  to open the provided link. This can be a web page URL or a deep link. If you
  have configured your app so that opening launching this intent will open a activity
  of your app, it should be possible to track which buttons was pressed.
</p>
<p>
  There is is also the option to add additional meta data to those intents. The
  included meta information contains information such as which buttons is pressed,
  the link given in the notification, the title and the message of the notification.
</p>
<p>
  By default this functionality is disabled and they are added as extras to the
  intent.
</p>
<div class="callout callout--warning">
  <h3 class="callout__title">Available after version 17.09</h3>
  <p>This feature is available for Android SDK 17.09 or later</p>
</div>
<p>
  In order to enable this functionality, you need to call this function before
  initializing Countly messaging:
</p>
<pre><code class="java">Countly.sharedInstance().setPushIntentAddMetadata(true);</code></pre>
<p>
  To access those extras from the intent, you should use these names:
</p>
<pre><code class="java">ProxyActivity.intentExtraButtonLink
ProxyActivity.intentExtraMessageText
ProxyActivity.intentExtraMessageTitle
ProxyActivity.intentExtraWhichButton</code></pre>
<p>
  To read the extra from the Intent, you would use something similar to this:
</p>
<pre><code class="java">String buttonUrl = intent.getStringExtra(ProxyActivity.intentExtraButtonLink);</code></pre>
<h1>Setting up crash reporting</h1>
<p>
  Countly SDK for Android has an ability to collect
  <a href="http://resources.count.ly/docs/introduction-to-crash-reporting-and-analytics">crash reports</a>
  which you can examine and resolve later on the server.
</p>
<h2>Enabling crash reporting</h2>
<p>
  Following function enables crash reporting, that will automatically catch uncaught
  Java exceptions.
</p>
<pre><code class="java">Countly.sharedInstance().enableCrashReporting()</code></pre>
<h2>Adding a custom key-value segment to a crash report</h2>
<p>
  You can add a key/value segments to crash report, like for example, which specific
  library or framework version you used in your app, so you can figure out if there
  is any correlation between specific library or other segment and crash reports.
</p>
<p>Use the following function for this purpose:</p>
<pre><code class="java">Countly.sharedInstance().setCustomCrashSegments(Map&lt;String, String&gt; segments)</code></pre>
<h2>Adding breadcrumbs</h2>
<p>
  Following command adds crash breadcrumb like log record to the log that will
  be send together with crash report.
</p>
<pre><code class="java">Countly.sharedInstance().addCrashLog(String record) </code></pre>
<h2>Logging handled exceptions</h2>
<p>
  You can also log handled exceptions on monitor how and when they are happening
  with the following command:
</p>
<pre><code class="java">Countly.sharedInstance().logException(Exception exception)</code></pre>
<h1>Additional SDK features</h1>
<h2>Testing</h2>
<p>
  You've probably noticed that we used
  <code>Countly.CountlyMessagingMode.TEST</code> in our example. That is because
  we're building the application for testing purposes for now. Countly separates
  users who run apps built for test and for release. This way you'll be able to
  test messages before sending them to all your users. When you're releasing the
  app, please use <code>Countly.CountlyMessagingMode.PRODUCTION</code>.
</p>
<h2>Push Notifications localization</h2>
<p>
  While push notification messages in Countly Messaging are properly localized,
  you can also localize the way notifications are displayed. By default, Countly
  uses your application name for a title of notification alert and the English
  word "Open" for the alert button name. If you want to customize it, pass an array
  of <code>String</code>s, where the button name is the first value, to
  <code>initMessaging</code> call:
</p>
<pre><code class="java">String[] pushLocalizationArray = new String[]{"Open"};
Countly.sharedInstance()
    .init(this, "YOUR_SERVER", "APP_KEY", null, DeviceId.Type.ADVERTISING_ID)
    .initMessaging(this, CountlyActivity.class, "PROJECT_ID", Countly.CountlyMessagingMode.TEST, pushLocalizationArray);</code></pre>
<h2>Geolocation-aware notifications (Enterprise Edition only)</h2>
<p>
  You can send notifications to users located at predefined locations. By default,
  Countly uses geoip database in order to bind your app users to their location.
  But if your app has access to better location data, you can submit it to the
  server:
</p>
<pre><code class="java">String latitude = "57.708358";
String longitude = "11.974950";

Countly.sharedInstance().setLocation(null, null, latitude + "," + longitude, null)</code></pre>
<h2>View tracking</h2>
<p>
  View tracking is a means to report every screen view to Countly dashboard. In
  order to enable automatic view tracking, call:
</p>
<pre><code class="java">Countly.sharedInstance().setViewTracking(true);</code></pre>
<p>
  The tracked views will use the full activity names which includes their package
  name. It would look similar to "com.my.company.activityname".
</p>
<div class="callout callout--warning">
  <h3 class="callout__title">Short view names available after version 17.09</h3>
</div>
<p>
  It is possible to use short view names which will use the simple activity name.
  That would look like "activityname". To use this functionality, call this before
  calling init:
</p>
<pre><code class="java">Countly.sharedInstance().setAutoTrackingUseShortName(true);</code></pre>
<p>
  Also you can track custom views with following code snippet:
</p>
<pre><code class="java">Countly.sharedInstance().recordView("View name")</code></pre>
<p>
  To review the resulting data, open the dashboard and go to
  <code>Analytics &gt; Views</code>. For more information on how to use view tracking
  data to it's fullest potential, look for more information
  <a href="http://resources.count.ly/docs/view-analytics">here</a>.
</p>
<div class="img-container">
  <img src="https://count.ly/images/guide/1059a04-3.PNG">
</div>
<h2>Receiving and showing badge number from push notifications</h2>
<div class="callout callout--info">
  <h3 class="callout__title">Minimum Countly Server Version</h3>
  <p>
    This feature is supported only on servers with the minimum version 16.12.2.
  </p>
</div>
<p>
  While showing badges isn't supported natively for versions before Android O,
  there are some devices and launchers that support it. Therefore you may want
  to implement such a feature in your app but not that not all devices will support
  badges.
</p>
<p>
  While creating a new message in the messaging overview and preparing it's content,
  there is a optional option called "Add iOS badge". You can use that to send badges
  also to Android devices.
</p>
<div class="img-container">
  <img src="https://count.ly/images/guide/5fbc4a2-Ekran_Resmi_2017-01-27_07.15.34.png">
</div>
<p>
  In order to receive this badge number in your application, you have to subscribe
  to the broadcasts about received messages. There, you are informed about all
  received push notifications using Message and bundle. The badge number is sent
  with the key "badge". You can use that to extract the badge number from the received
  bundle and then use it to display badge numbers with your implementation of choice.
</p>
<p>
  In the below example we will use a badge library called
  <a href="https://github.com/leolin310148/ShortcutBadger">ShortcutBadger</a>,
  which is used to show badges on Android. Follow their instructions
  <a href="https://github.com/leolin310148/ShortcutBadger#usage">in this link</a>
  on how to use it in your Androidproject. You can also see the same example inside
  <a href="https://github.com/Countly/countly-sdk-android/tree/master/app-messaging">Countly messaging sample project</a>.
</p>
<pre><code class="java">/** Register for broadcast action if you need to be notified when Countly message received */
messageReceiver = new BroadcastReceiver() {
    @Override
    public void onReceive(Context context, Intent intent) {
        Message message = intent.getParcelableExtra(CountlyMessaging.BROADCAST_RECEIVER_ACTION_MESSAGE);
        Log.i("CountlyActivity", "Got a message with data: " + message.getData());

        //Badge related things
        Bundle data = message.getData();
        String badgeString = data.getString("badge");
        try {
            int badgeCount = Integer.parseInt(badgeString);

            boolean succeded = ShortcutBadger.applyCount(getApplicationContext(), badgeCount);
            if(!succeded) {
                Toast.makeText(getApplicationContext(), "Unable to put badge", Toast.LENGTH_SHORT).show();
            }
        } catch (NumberFormatException exception) {
            Toast.makeText(getApplicationContext(), "Unable to parse given badge number", Toast.LENGTH_SHORT).show();
        }
    }
};
IntentFilter filter = new IntentFilter();
filter.addAction(CountlyMessaging.getBroadcastAction(getApplicationContext()));
registerReceiver(messageReceiver, filter);</code></pre>
<h2>Checking if init has been called</h2>
<p>
  In case you want to check if init has been called, you can just use the following
  function:
</p>
<pre><code class="java">Countly.sharedInstance().isInitialized();</code></pre>
<h2>Checking if onStart has been called</h2>
<p>
  For some applications there might a use case where the developer would like to
  check if the Countly sdk<code>onStart</code> function has been called. For that
  they can use the following call:
</p>
<pre><code class="java">Countly.sharedInstance().hasBeenCalledOnStart();</code></pre>
<h2>Ignoring app crawlers</h2>
<p>
  Sometimes server data might be polluted with app crawlers which are not real
  users, and you would like to ignore them. Starting from the 17.05 release it's
  possible to do that filtering on the app level. The current version does that
  using device names. Internally the Countly sdk has a list for crawler device
  names, if a device name matches one from that list, no information is sent to
  the server. At the moment that list has only one entry: "Calypso AppCrawler".
  In the future we might add more crawler device names if such are reported. If
  you have encountered a crawler that is not in that list, but you would like to
  ignore, you can add it to your sdk list yourself by calling
  <code>addAppCrawlerName</code>. Currently by default the sdk is ignoring crawlers,
  if you would like to change that, use <code>ifShouldIgnoreCrawlers</code>. If
  you want to check if the current device was detected as a crawler, use
  <code>isDeviceAppCrawler</code>. Detection is done in the init function, so you
  would have to add the crawler names before that and do the check after that.
</p>
<pre><code class="java">//set that the sdk should ignore app crawlers
Countly.sharedInstance().ifShouldIgnoreCrawlers(true);

//set that the sdk should not ignore app crawlers
Countly.sharedInstance().ifShouldIgnoreCrawlers(false);

//add another app crawler device name to ignore
Countly.sharedInstance().addAppCrawlerName("App crawler");

//returns true if this device is detected as a app crawler and false otherwise
Countly.sharedInstance().isDeviceAppCrawler();f</code></pre>
<h2>Setting Custom HTTP header values</h2>
<p>
  In case you want to add custom header key/value pairs to each request sent to
  the countly server, you can make the following call:
</p>
<pre><code class="text">HashMap&lt;String, String&gt; customHeaderValues = new HashMap&lt;&gt;();
customHeaderValues.put("foo", "bar");

Countly.sharedInstance().addCustomNetworkRequestHeaders(customHeaderValues);</code></pre>
<p>
  The provided values will override any previously stored value pairs. In case
  you want to erase previously stored pairs, provide <code>null</code>.
</p>
<h1>Native C++ Crash Reporting</h1>
<p>
  Countly uses
  <a href="https://github.com/google/breakpad">Google's Breakpad open source library</a>
  to be able to report crashes that occured in C++ components of your application
  if you have any. Breakpad provides: a) a tool for creating symbol files from
  your object files (<code>dump_syms</code>) b) ability to detect crashes and record
  crashes via compact minidump files (crash handler) c) a tool for generating human
  readable stack traces by using symbol files and and crash minidump files.
</p>
<div class="img-container">
  <img src="https://count.ly/images/guide/7cbb985-breakpad.png">
</div>
<p>
  Countly provides
  <a href="https://github.com/Countly/countly-sdk-android/tree/master/sdk-native"><code>sdk_native</code></a>
  Android library to add crash handler to your native code and create crash minidump
  files. SDK will check for those minidump files and send them automatically to
  your Countly server on application start. You can download
  <code>sdk_native</code> from default JCenter repository or Bintray Maven repository
  and include it in your project similar to how you included our SDK (please change
  <code>LATEST_VERSION</code> below by checking our maven
  <a href="https://bintray.com/countly/maven/sdk-native">page</a>, currently it
  is 19.02.3):
</p>
<pre><code class="text">// build gradle file 

repositories {
    maven {
        url 'https://dl.bintray.com/countly/maven'
    }
    jcenter()
}

dependencies {
    implementation 'ly.count.android:sdk-native:LATEST_VERSION'
}</code></pre>
<p>
  Then call our init method as early as possible in your application life cycle
  to be able to catch crashes that occur during initialization:
</p>
<pre><code class="java">import ly.count.android.sdknative.CountlyNative;

CountlyNative.initNative(getApplicationContext());</code></pre>
<p>
  <code>getApplicationContext()</code> is needed to determine a storage place for
  minidump files.
</p>
<p>
  <strong>Automatic creation and upload of symbol files</strong>
</p>
<p>
  You can create Breakpad symbols files yourself and upload them to your Countly
  server using our UI. They will be needed to create stack traces from minidump
  files. Countly also developed a Gradle plugin to automate this process. To use
  upload plugin in Studio we need to include it first (LATEST_VERSION is currently
  19.02.3):
</p>
<pre><code class="text">apply plugin: ly.count.android.plugins.UploadSymbolsPlugin 

buildscript {
    repositories {
        maven {
            url 'https://dl.bintray.com/countly/maven'
        }
        jcenter()
    }
    // for LATEST_VERSION check https://bintray.com/countly/maven/sdk-plugin
    dependencies {
        classpath group: 'ly.count.android', 'name': 'sdk-plugin', 'version': 'LATEST_VERSION'
    }
}</code></pre>
<p>
  Then you need to configure a gradle countly block for the plugin:
</p>
<pre><code class="text">countly {
    server "https://YOUR_SERVER", 
    app_key "YOUR_APP_KEY"  
}</code></pre>
<p>
  Then you will have two new Gradle tasks available to you:
  <code>uploadJavaSymbols</code> and <code>uploadNativeSymbols</code>.
  <code>uploadJavaSymbols</code> is for uploading the <code>mapping.txt</code>
  file generated by Proguard. After building your project you can run these tasks
  through Studio's Gradle tool window (1). They will be available under your app
  (2) and grouped as countly tasks (3).
</p>
<div class="img-container">
  <img src="https://count.ly/images/guide/6ddc195-Selection_006.png">
</div>
<p>Another option is to run them from command line:</p>
<pre><code class="text">./gradlew uploadNativeSymbols

// or if you have subprojects

./gradlew :project-name:uploadNativeSymbols</code></pre>
<p>
  You can also configure your build so these tasks will be run after every build:
</p>
<pre><code class="text">tasks.whenTaskAdded { task -&gt;
    if (task.name.startsWith('assemble')) {
        task.dependsOn('uploadNativeSymbols')
    }
}</code></pre>
<p>
  In addition to specify your server and app info you can also override some default
  values in countly block.
</p>
<pre><code class="text">countly {
  // required by both tasks
  server "https://try.count.ly"
  app_key "XXXXXX"  // same app_key used for SDK integration

  // optional properties for uploadJavaSymbols. Shown are the default values.

  // location of mapping.txt file relative to project build directory
  mappingFile "outputs/mapping/release/mapping.txt"

  // note that will be saved with the upload and can be checked in the UI
  noteJava "sdk-plugin automatic upload of mapping.txt"

  // optional properties for uploadNativeSymbols. Shown are the default values.

  // directory of .so files relative to project build directory.
  // you can check the tar.gz file created under intermediates/countly
  nativeObjectFilesDir "intermediates/cmake/release/obj"

  // path for breakpad tool dump_syms executable
  dumpSymsPath "/usr/bin/dump_syms"

  // note that will be saved with the upload and can be checked in the UI
  noteNative "sdk-plugin automatic upload of breakpad symbols"

}
</code></pre>
<p>
  Two of these properties are possibly needs to be configured by you:
  <code>dumpSymsPath</code> and <code>nativeObjectFilesDir</code>. Plugin assumes
  you will run the task after a release build. To test it for debug builds please
  change <code>nativeObjectFilesDir</code> to be
  <code>"intermediates/cmake/debug/obj"</code> (or whereever your build process
  puts .so files under build directory).
</p>
<p>
  We created a
  <a href="https://github.com/Countly/countly-sdk-android/tree/master/app-native">sample app</a>
  in our github repo that demostrates both how to use sdk-native and our upload
  plugin.
</p>
<h1>Building Android SDK</h1>
<p>
  If you need to customize our Android SDK for your needs, you can find it
  <a href="https://github.com/Countly/countly-sdk-android">here</a> among our Countly
  Github repositories as an Android Studio project. Modules included in the project
  are:
</p>
<table>
  <tbody>
    <tr>
      <th>Module Name</th>
      <th>Description</th>
    </tr>
    <tr>
      <td>
        <code>sdk</code>
      </td>
      <td>Main functionality of Android SDK. No push notifcation</td>
    </tr>
    <tr>
      <td>
        <code>app</code>
      </td>
      <td>
        Sample app to test <code>sdk</code>
      </td>
    </tr>
    <tr>
      <td>
        <code>sdk-messaging</code>
      </td>
      <td>
        <code>sdk</code> +
        <a href="https://resources.count.ly/docs/countly-sdk-for-android#section-setting-up-push-notifications">Push notifications</a>
        (GCM integration). May be removed in upcoming releases.
      </td>
    </tr>
    <tr>
      <td>
        <code>app-messaging</code>
      </td>
      <td>
        Sample app to test <code>sdk-messaging</code>
      </td>
    </tr>
    <tr>
      <td>
        <code>sdk-messaging-fcm</code>
      </td>
      <td>Push notifications ( FCM integration).</td>
    </tr>
    <tr>
      <td>
        <code>app-messaging-fcm</code>
      </td>
      <td>
        Sample app to test <code>sdk-messaging-fcm</code>
      </td>
    </tr>
    <tr>
      <td>
        <code>sdk-native</code>
      </td>
      <td>
        Module needed for
        <a href="https://resources.count.ly/docs/countly-sdk-for-android#section-native-c-crash-reporting">Native C++ crash reporting</a>
      </td>
    </tr>
    <tr>
      <td>
        <code>app-native</code>
      </td>
      <td>
        Sample app to test <code>sdk-native</code>
      </td>
    </tr>
  </tbody>
</table>
<p>
  In recent Android Studio versions there is a
  <a href="https://github.com/Countly/countly-sdk-android/issues/96#issuecomment-492327285">bug</a>
  you may encounter when you build the project in Studio. If you see a build error
  like <code>SIMPLE: Error configuring</code> please check your text view for build
  gradle output. If there is an error about
  <code>CMake was unable to find a build program corresponding to "Ninja". CMAKE_MAKE_PROGRAM is not set</code>
  then you need <code>ninja</code> to be available in your <code>PATH</code>. If
  you are using <code>cmake</code> embedded in Studio, <code>ninja</code> can be
  found at <code>&lt;sdk_location&gt;/cmake/&lt;cmake_version&gt;/bin</code> directory.
</p>
<p>
  For the <code>sdk-native</code> module there is a build step which happens outside
  of Studio. You may find the related code and build scripts in
  <code>sdk-native/src/cpp_precompilation</code>. We are working on building breakpad
  library with an appropriate ndk version to integrate this step into Studio build.
  Meanwhile, it seems OK to use the library files in
  <code>sdk-native/src/main/jniLibs/</code> that are externally built.
</p>
