<p>This documentation applies to the version 20.4.</p>
<p>
  <br>
  This document includes necessary information for integrating Countly Flutter
  SDK in your application. Flutter SDK requires Android and iOS SDKs, hence all
  the features and limitations regarding those platforms also apply to Countly
  Flutter SDK.
</p>
<h1>Installing the SDK</h1>
<p>
  Add this to your package's <code>pubspec.yaml</code> file:
</p>
<pre><code class="yaml">dependencies:
  countly_flutter:
    git: 
      url: https://github.com/Countly/countly-sdk-flutter-bridge.git
      ref: master
</code></pre>
<p>
  You can install packages from the command line with Flutter:
</p>
<pre><code class="shell">flutter pub get</code></pre>
<h1>Example Flutter application</h1>
<p>
  Below you can see steps to download a Flutter example application:
</p>
<pre><code class="shell">git clone https://github.com/Countly/countly-sdk-flutter-bridge.git
cd countly-sdk-flutter-bridge/example
flutter pub get
flutter run</code></pre>
<p>
  This example application has all the methods mentioned in this documentation.
  It is a great way of understanding how different methods work, like custom events,
  custom user profiles and views.
</p>
<h1>Implementation</h1>
<p>
  Below you can find necessary code snippets to initialize the SDK for sending
  data to Countly servers. Where possible, use your server URL instead of
  <code>try.count.ly</code> in case you have your own server.
</p>
<h1>Initialization</h1>
<p>
  The shortest way to initiate the SDK if you want Countly SDK to take care of
  device ID seamlessly, use the code below. You can find your app key on your Countly
  dashboard, under the "Applications" menu item.
</p>
<pre><span>// use your server name below if required.<br></span>Countly.<span>isInitialized</span>().then((bool isInitialized){<br>  <span>if</span>(!isInitialized){<br>      // Features which is required before init should be call here<br>    <strong>Countly.init("https://try.count.ly", APP_KEY)</strong>.then((value){<br>      <span>//Features dependent on init should be set here, for e.g Push notifications and consent.<br></span><span>    </span>});<br>  }<span>else</span>{<br>    print(<span>"Countly: Already initialized."</span>);<br>  }<br>});</pre>
<h1>Enabling logging</h1>
<p>
  If logging is enabled then our SDK will print out debug messages about its internal
  state and encountered problems.
</p>
<p>
  We advise doing this while implementing Countly features in your application.
</p>
<pre><code class="javascript">Countly.setLoggingEnabled(true);</code></pre>
<h1>Checking if the SDK has been initialized&nbsp;</h1>
<div class="callout callout--info">
  <p class="callout__title">
    <span class="wysiwyg-font-size-large"><strong>Minimum Countly SDK Version</strong></span>
  </p>
  <p>
    This feature is only supported by the minimum SDK version 20.04.1.
  </p>
</div>
<p>
  <span style="font-weight:400">In case you would like to check if init has been called, you may use the following function:</span>
</p>
<pre>Countly.<span>isInitialized</span>();</pre>
<h1>Device ID</h1>
<p>
  <span style="font-weight:400"><span>When the SDK is initialized for the first time and no device ID is provided, a device ID will be generated by SDK.</span></span><span style="font-weight:400"><span></span></span>
</p>
<p>
  <span style="font-weight:400"><span>For iOS: the device ID generated by SDK is the Identifier For Vendor (IDFV)<br>For Android:&nbsp; the device ID generated by SDK is the OpenUDID or Google Advertising ID</span></span>
</p>
<p>
  <span style="font-weight:400"><span>You may provide your own custom device ID when</span> initializing the SDK</span>
</p>
<pre>Countly.<span>init</span>(<span>SERVER_URL</span>, <span>APP_KEY, DEVICE_ID</span>)</pre>
<h2>
  Changing the Device ID<span style="font-weight:400"></span>
</h2>
<p>
  <span style="font-weight:400">You may configure/change the device ID anytime using:<br></span>
</p>
<pre>Countly.<span>changeDeviceId</span>(DEVICE_ID, <span>ON_SERVER</span>);</pre>
<p>
  <span>You may either allow the device to be counted as a new device or merge existing data on the server. </span>If
  the<code>onServer</code><span>&nbsp;</span>bool is set to <code>true</code>,
  <span>the old device ID on the server will be replaced with the new one, and data associated with the old device ID will be merged automatically.<br>Otherwise, if&nbsp;<code>onServer</code> bool is&nbsp;set to <code>false</code>, the device will be counted as a new device on the server.<br></span>
</p>
<h2 id="temporary-device-id" class="anchor-heading">Temporary Device ID</h2>
<p>
  You may use a temporary device ID mode for keeping all requests on hold until
  the real device ID is set later.&nbsp;
</p>
<p>
  You can enable temporary device ID
  <span style="font-weight:400">when initializing the SDK:</span>
</p>
<pre>Countly.<span>init</span>(<span>SERVER_URL</span>, <span>APP_KEY, Countly.deviceIDType["TemporaryDeviceID"]</span>)</pre>
<p>To enable a temporary device ID after init, you would call:</p>
<pre>Countly.<span>changeDeviceId</span>(Countly.deviceIDType["TemporaryDeviceID"], <span>ON_SERVER</span>);</pre>
<p>
  &nbsp;<strong>Note:</strong>&nbsp;When passing<span> </span><code>TemporaryDeviceID</code><span>&nbsp;</span>for<span>&nbsp;</span><code>deviceID</code><span>&nbsp;</span>parameter,
  argument for<span>&nbsp;</span><code>onServer</code>parameter does not matter.
</p>
<p>
  As long as the device ID value is<span> </span><code>TemporaryDeviceID</code>,
  the SDK will be in temporary device ID mode and all requests will be on hold,
  but they will be persistently stored.
</p>
<p>
  When in temporary device ID mode, method calls for presenting feedback widgets
  and updating remote config will be ignored.
</p>
<p>
  Later, when the real device ID is set using<span> </span><code>Countly.<span>changeDeviceId</span>(DEVICE_ID, <span>ON_SERVER</span>);</code><span>&nbsp;</span>method,
  all requests which have been kept on hold until that point will start with the
  real device ID
</p>
<h1>Parameter tampering protection</h1>
<p>
  You can set optional <code>salt</code> to be used for calculating checksum of
  request data, which will be sent with each request using
  <code>&amp;checksum</code> field. You need to set exactly the same
  <code>salt</code> on the Countly server. If <code>salt</code> on Countly server
  is set, all requests would be checked for the validity of
  <code>&amp;checksum</code>&nbsp; field before being processed.
</p>
<pre><code class="javascript">// sending data with salt
Countly.enableParameterTamperingProtection("salt");</code></pre>
<p>
  Make sure not to use salt on the Countly server and not on the SDK side, otherwise,
  Countly won't accept any incoming requests.
</p>
<h1>Optional parameters during initialization</h1>
<p>
  You can provide optional parameters that will be used during begin_session request.
  They must be set right after the <code>init</code> function so that they are
  set before the request is sent to the server. To set them, use the
  <code>setOptionalParametersForInitialization</code> function. If you want to
  set those optional parameters, this function has to be called every time the
  app starts. If you don't want to set one off those values, leave that field
  <code>null</code>.
</p>
<p>The optional parameters are:</p>
<ul>
  <li>Country code: ISO Country code for the user's country</li>
  <li>City: Name of the user's city</li>
  <li>
    Location: Comma separate latitude and longitude values, for example "56.42345,123.45325"
  </li>
  <li style="box-sizing:border-box;margin-bottom:calc(12px)">
    <span style="box-sizing:border-box;font-weight:400">Your user's IP address</span>
  </li>
</ul>
<pre><code class="javascript">
//setting optional parameters
Map&lt;String, Object&gt; options = {
    "city": "Tampa",
    "country": "US",
    "latitude": "28.006324",
    "longitude": "-82.7166183",
    "ipAddress": "255.255.255.255"
};
Countly.setOptionalParametersForInitialization(options);


//and then call the below code
Countly.init(this, "https://YOUR_SERVER", "YOUR_APP_KEY", "YOUR_DEVICE_ID")
</code></pre>
<h1>Forcing HTTP POST</h1>
<p>
  If the data sent to the server is short enough, the SDK will use HTTP GET requests.
  In case you want an override so that HTTP POST is used in all cases, call the
  <code>setHttpPostForced</code> function after you called <code>init</code>. You
  can use the same function later in the app's life cycle to disable the override.
  This function has to be called every time the app starts.
</p>
<pre><code class="javascript"> Countly.setHttpPostForced(true); // default is false</code></pre>
<h1>Session control</h1>
<p>To start recording a session you would start it with:</p>
<pre><code class="javascript">Countly.start();</code></pre>
<p>
  If you want to end recording the current session, you would call:
</p>
<pre><code class="javascript">Countly.stop();</code></pre>
<h1>Recording an event</h1>
<p>
  A custom event is any type of action that you can send to a Countly instance,
  e.g purchase, settings changed, view enabled and so. This way it's possible to
  get much more information from your application compared to what is sent from
  Flutter SDK to Countly instance by default.
</p>
<div class="callout callout--info">
  <p class="callout__title">
    <strong><span class="wysiwyg-font-size-large">Data passed should be in UTF-8</span></strong>
  </p>
  <p>
    All data passed to the Countly server via SDK or API should be in UTF-8.
  </p>
</div>
<p>
  As an example, we will be recording a purchase event. Here is a quick summary
  of what information each usage will provide us:
</p>
<ul>
  <li>Usage 1: how many times a purchase event occurred.</li>
  <li>
    Usage 2: how many times purchase event occurred + the total amount of those
    purchases.
  </li>
  <li>
    Usage 3: how many times purchase event occurred + which countries and application
    versions those purchases were made from.
  </li>
  <li>
    Usage 4: how many times a purchase event occurred + the total amount both
    of which are also available segmented into countries and application versions.
  </li>
  <li>
    Usage 5: how many times purchase event occurred + the total amount both of
    which are also available segmented into countries and application versions
    + the total duration of those events (under Timed Events topic below)
  </li>
</ul>
<h2>1. Event key and count</h2>
<pre><code class="javascript">// example for sending basic custom event
var event = {
  "key": "Basic Event",
  "count": 1
};
Countly.recordEvent(event);</code></pre>
<h2>2. Event key, count and sum</h2>
<pre><code class="javascript">// example for event with sum
var event = {
  "key": "Event With Sum",
  "count": 1,
  "sum": "0.99",
};
Countly.recordEvent(event);
</code></pre>
<h2>3. Event key and count with segmentation(s)</h2>
<pre><code class="javascript">// example for event with segment
var event = {
  "key": "Event With Segment",
  "count": 1
};
event["segmentation"] = {
  "Country": "Germany",
  "Age": "28"
};
Countly.recordEvent(event);
</code></pre>
<h2>4. Event key, count and sum with segmentation(s)</h2>
<pre><code class="javascript">
// example for event with segment and sum
var event = {
  "key": "Event With Sum And Segment",
  "count": 1,
  "sum": "0.99"
};
event["segmentation"] = {
  "Country": "Germany",
  "Age": "28"
};
Countly.recordEvent(event);
</code></pre>
<h1>Timed events</h1>
<h2>1.Timed event with key</h2>
<pre><code class="javascript">// Basic event
Countly.startEvent("Timed Event");
Timer timer;
timer = new Timer(new Duration(seconds: 5), () {
    Countly.endEvent({ "key": "Timed Event" });
    timer.cancel();
});
</code></pre>
<h2>2.Timed event with key and sum</h2>
<pre><code class="javascript">// Event with sum
Countly.startEvent("Timed Event With Sum");
Timer timer;
timer = new Timer(new Duration(seconds: 5), () {
    Countly.endEvent({ "key": "Timed Event With Sum", "sum": "0.99" });
    timer.cancel();
});
</code></pre>
<h2>3.Timed event with key, count and segmentation</h2>
<pre><code class="javascript">// Event with segment
Countly.startEvent("Timed Event With Segment");
Timer timer;
timer = new Timer(new Duration(seconds: 5), () {
    var event = {
        "key": "Timed Event With Segment",
        "count": 1,
    };
    event["segmentation"] = {
      	"Country": "Germany",
      	"Age": "28"
    };
    Countly.endEvent(event);
    timer.cancel();
});</code></pre>
<h2>4.Timed event with key, count, sum and segmentation</h2>
<pre><code class="javascript">// Event with Segment, sum and count
Countly.startEvent("Timed Event With Segment, Sum and Count");
Timer timer;
timer = new Timer(new Duration(seconds: 5), () {
    var event = {
        "key": "Timed Event With Segment, Sum and Count",
        "count": 1,
        "sum": "0.99"
    };
    event["segmentation"] = {
        "Country": "Germany",
        "Age": "28"
    };
    Countly.endEvent(event);
    timer.cancel();
});</code></pre>
<h1>User Profiles</h1>
<p>
  In order to set a user profile, use the code snippet below. After you send user
  data, it can be viewed under the User Profiles menu.
</p>
<p>
  Note that this feature is available only for Enterprise Edition.
</p>
<pre><code class="javascript">// example for setting user data
Map&lt;String, Object&gt; options = {
    "name": "Nicola Tesla",
    "username": "nicola",
    "email": "info@nicola.tesla",
    "organization": "Trust Electric Ltd",
    "phone": "+90 822 140 2546",
    "picture": "http://images2.fanpop.com/images/photos/3300000/Nikola-Tesla-nikola-tesla-3365940-600-738.jpg",
    "picturePath": "",
    "gender": "M", // "F"
    "byear": "1919",
};
Countly.setUserData(options);</code></pre>
<p>
  In order to modify a user's data (e.g increment, etc), the following code sample
  can be used.
</p>
<h2>Modifying custom data</h2>
<p>
  Additionally, you can do different manipulations on your custom data values,
  like increment current value on the server or store an array of values under
  the same property.
</p>
<p>Below is the list of available methods:</p>
<pre><code class="javascript">
//set one custom properties
Countly.setProperty("setProperty", "My Property");
//increment used value by 1
Countly.increment("increment");
//increment used value by provided value
Countly.incrementBy("incrementBy", 10);
//multiply value by provided value
Countly.multiply("multiply", 20);
//save maximal value
Countly.saveMax("saveMax", 100);
//save minimal value
Countly.saveMin("saveMin", 50);
//set value if it does not exist
Countly.setOnce("setOnce", 200);

//insert value to array of unique values
Countly.pushUniqueValue("type", "morning");;
//insert value to array which can have duplicates
Countly.pushValue("type", "morning");
//remove value from array
Countly.pullValue("type", "morning");
</code></pre>
<h1>Crash reporting</h1>
<p>
  This feature allows the Countly SDK to record crash reports of either encountered
  issues of exceptions which cause your application to crash. Those reports will
  be sent to your Countly server for further inspection.
</p>
<p>
  If a crash report can not be delivered to the server (e.g. no internet connection,
  unavailable server), then SDK stores the crash report locally in order to try
  again later.
</p>
<h2>Enabling crash reporting</h2>
<p>
  If you want to enable automatic unhandled crash reporting, you need to call this
  before init:
</p>
<pre>Countly.<span>enableCrashReporting</span>()</pre>
<p>
  By doing that it will automatically catch all errors that are thrown from within
  the Flutter framework.
</p>
<p>
  <br>
  If you want to catch Dart errors,&nbsp;<span>run your app inside a&nbsp;Zone and&nbsp;</span>supply&nbsp;<code>Countly.recordDartError</code>&nbsp;to
  the&nbsp;<code>onError</code>&nbsp;parameter:
</p>
<div class="callout callout--info">
  <p class="callout__title">
    <strong><span class="wysiwyg-font-size-large">Minimum Countly SDK Version</span></strong>
  </p>
  <p>
    This feature is only supported by the minimum SDK version 20.04.1.
  </p>
</div>
<pre><span>void </span>main() {<br>  runZonedGuarded&lt;Future&lt;<span>void</span>&gt;&gt;(() <span>async </span>{<br>    runApp(<span>MyApp</span>());<br>  }, Countly.<span>recordDartError</span>);<br>}<span></span></pre>
<h2>Adding a custom key-value segment to a crash report</h2>
<p>
  <span style="font-weight:400">You may add a key/value segment to crash reports. For example, you could set which specific library or framework version you used in your app. You may then figure out if there is any correlation between the specific library or another segment and the crash reports.</span><span style="font-weight:400"></span>
</p>
<div class="callout callout--info">
  <p class="callout__title">
    <strong><span class="wysiwyg-font-size-large">Minimum Countly SDK Version</span></strong>
  </p>
  <p>
    This feature is only supported by the minimum SDK version 20.04.1.
  </p>
</div>
<p>
  <span style="font-weight:400">The following call will add the provided segmentation to all recorded crashes. Use the following function for this purpose:</span>
</p>
<pre><span>Countly.setCustomCrashSegment</span>(Map&lt;String, Object&gt; segments);</pre>
<h2>
  <span>Adding breadcrumbs</span>
</h2>
<p>
  Throughout your app, you can leave&nbsp;crash breadcrumbs which would describe
  previous steps that were taken in your app before the crash. After a crash happens,
  they will be sent together with the crash report.
</p>
<p>Following the command adds crash breadcrumb:</p>
<pre>Countly.<span>addCrashLog</span>(<span>String logs</span>)</pre>
<h2>
  <span>Logging an exceptions</span>
</h2>
<p class="p1">
  There are multiple ways you could report a handled exception/error to Countly.
</p>
<p class="p1">
  This call does not add a stacktrace automatically&nbsp;if it's needed, it should
  already be added to the exception variable, a&nbsp;potential use case would be
  to provide <code>exception.toString()</code>
</p>
<pre><span>Countly.logException</span>(String exception, bool nonfatal, [Map&lt;String, Object&gt; segmentation])</pre>
<div class="callout callout--info">
  <p class="callout__title">
    <strong><span class="wysiwyg-font-size-large">Minimum Countly SDK Version</span></strong>
  </p>
  <p>
    The following calls are only supported starting from the SDK version 20.04.1.
  </p>
</div>
<p>
  The issue is recorded with a provided Exception object. If no stacktrace is set,<span class="s1"><code>StackTrace.current</code></span>&nbsp;will
  be used.
</p>
<pre><span>Countly.logExceptionEx</span>(Exception exception, bool nonfatal, {StackTrace stacktrace, Map&lt;String, Object&gt; segmentation})</pre>
<p class="p1">
  The exception/error is recorded through a string message. If no stack trace is
  provided,&nbsp;<span class="s1">&nbsp;<code>StackTrace.current</code></span>&nbsp;will
  be used.
</p>
<pre><span>Countly.logExceptionManual</span>(String message, bool nonfatal, {StackTrace stacktrace, Map&lt;String, Object&gt; segmentation})</pre>
<h1>View tracking</h1>
<p>
  You can manually add your own views in your application, and each view will be
  visible under Views menu item. Below you can see two examples of sending a view
  using <code>Countly.recordview</code> function.
</p>
<pre><code class="javascript">// record a view on your application
Countly.recordView("HomePage");
Countly.recordView("Dashboard");</code></pre>
<div class="callout callout--info">
  <p class="callout__title">
    <strong><span class="wysiwyg-font-size-large">Minimum Countly SDK Version</span></strong>
  </p>
  <p>
    This feature is only supported by the minimum SDK version 20.04.1.
  </p>
</div>
<p>
  While manually tracking views, you may want to add custom segmentation to them.
</p>
<pre>Map&lt;String, Object&gt; segments = {<br>  <span>"Cats"</span>: <span>123</span>,<br>  <span>"Moons"</span>: <span>9.98</span>,<br>  <span>"Moose"</span>: <span>"Deer"<br></span>};<br>Countly.<span>recordView</span>(<span>"HomePage"</span>, segments);</pre>
<p>&nbsp;</p>
<h1>Application Performance Monitoring</h1>
<div class="callout callout--info">
  <p class="callout__title">
    <strong><span class="wysiwyg-font-size-large">Minimum Countly SDK Version</span></strong>
  </p>
  <p>
    This feature is only supported by the minimum SDK version 20.04.1.
  </p>
</div>
<p>
  This SDK provides a few mechanisms for APM. To start using them you would first
  need to enable this feature and give the required consent if it was required.
</p>
<pre>Countly.<span>enableApm</span>(); <span>// Enable APM features, which includes the recording of app start time.</span></pre>
<p>
  While using APM calls, you have the ability to provide trace keys by which you
  can track those parameters in your dashboard.
</p>
<h2>Custom trace</h2>
<p>
  Currently, you can use custom traces to record the duration of application processes.
  At the end of them, you can also provide any additionally gathered data.
</p>
<p>
  The trace key uniquely identifies the thing you are tracking and the same name
  will be shown in the dashboard. The SDK does not support tracking multiple events
  with the same key.
</p>
<p>To start a custom trace, use:</p>
<pre>Countly.<span>startTrace</span>(traceKey);</pre>
<p>To end a custom trace, use:</p>
<pre>String traceKey = <span>"Trace Key"</span>;<br>Map&lt;String, int&gt; customMetric = {<br>  <span>"ABC"</span>: <span>1233</span>,<br>  <span>"C44C"</span>: <span>1337<br></span>};<br>Countly.<span>endTrace</span>(traceKey, customMetric);</pre>
<p>
  The provided Map of integer values that will be added to that trace in the dashboard.
</p>
<h2>Network trace</h2>
<p>
  You can use the APM to track your requests. You would record the required info
  for your selected approach of making network requests and then call this after
  your network request is done:
</p>
<pre>Countly.<span>recordNetworkTrace</span>(networkTraceKey, responseCode, requestPayloadSize, responsePayloadSize, startTime, endTime);</pre>
<p>
  `networkTraceKey` is a unique identifier of the API endpoint you are targeting
  or just the url you are targeting, all params should be stripped. You would also
  provide the received response code, sent payload size in bytes, received payload
  size in bytes, request start time timestamp in milliseconds, and request end
  finish timestamp in milliseconds.
</p>
<h1>Using Proguard</h1>
<p>
  <span style="font-weight:400">Proguard obfuscates the OpenUDID &amp; Countly Messaging classes. If you use OpenUDID or Countly Messaging in your application, f<span>ind <strong class="ib cf">app/proguard-rules.pro</strong></span><span>&nbsp;file which sits inside&nbsp;</span><strong class="ib cf">/android/app/</strong><span> folder and adds the following lines:</span></span>
</p>
<pre><code class="java">-keep class org.openudid.** { *; }
-keep class ly.count.android.sdk.** { *; }</code></pre>
<p>
  <span>If <span style="font-weight:400">Proguard is not already configured then</span> first, enable shrinking and obfuscation in the build file. Find </span><strong class="ib cf">build.gradle</strong><span>&nbsp;file which sits inside&nbsp;</span><strong class="ib cf">/android/app/</strong><span> folder and adds lines in bold<br></span>
</p>
<pre><span class="pln">android </span><span class="pun">{</span><span class="pln"><br>&nbsp; &nbsp; buildTypes </span><span class="pun">{</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; release </span><span class="pun">{</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">// Enables code shrinking, obfuscation, and optimization for only</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">// your project's release build type.</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <strong>minifyEnabled </strong></span><strong><span class="kwd">true</span></strong><span class="pln"><br><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">// Enables resource shrinking, which is performed by the</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">// Android Gradle plugin.</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <strong>shrinkResources </strong></span><strong><span class="kwd">true</span></strong><span class="pln"><br><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">// Includes the default ProGuard rules files that are packaged with</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">// the Android Gradle plugin. To learn more, go to the section about</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">// R8 configuration files.</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <strong>proguardFiles getDefaultProguardFile</strong></span><strong><span class="pun">(</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="str">'proguard-android-optimize.txt'</span><span class="pun">),</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="str">'proguard-rules.pro'</span></strong><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="pun">}</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">}<br></span><span class="pln">    ...<br></span><span class="pun">}</span></pre>
<p id="0858" class="hz ia gi ib b ic it id ie if iu ig ih ii iv ij ik il iw im in io ix ip iq is cs ev" data-selectable-paragraph="">
  Next create a configuration that will preserve the entire Flutter wrapper code.
  Create<strong class="ib cf"><span>&nbsp;</span>/android/app/proguard-rules.pro</strong><span>&nbsp;</span>file
  and insert inside:
</p>
<pre class="iy iz ja jb jc jd je jf"><span id="0590" class="ev jg jh gi ji b ct jj jk s jl" data-selectable-paragraph="">#Flutter Wrapper<br>-keep class io.flutter.app.** { *; }<br>-keep class io.flutter.plugin.**  { *; }<br>-keep class io.flutter.util.**  { *; }<br>-keep class io.flutter.view.**  { *; }<br>-keep class io.flutter.**  { *; }<br>-keep class io.flutter.plugins.**  { *; }</span></pre>
<p>
  More info related to code shrinking can be found here for
  <a href="https://flutter.dev/docs/deployment/android#shrinking-your-code-with-r8">flutter</a>
  and
  <a href="https://developer.android.com/studio/build/shrink-code#keep-code" target="_blank" rel="noopener">android</a>.
</p>
<h1>Attribution analytics &amp; install campaigns&nbsp;</h1>
<div class="callout callout--info">
  <p class="callout__title">
    <strong><span class="wysiwyg-font-size-large">Minimum Countly SDK Version</span></strong>
  </p>
  <p>
    This feature is only supported by the minimum SDK version 20.04.1.
  </p>
</div>
<p>
  <a href="https://count.ly/attribution-analytics">Countly Attribution Analytics</a>
  allows you to measure your marketing campaign performance by attributing installs
  from specific campaigns. This feature is available for the Enterprise Edition.
</p>
<p>Call this before init.</p>
<pre><span>// Enable to measure your marketing campaign performance by attributing installs from specific campaigns.</span><br>Countly.<span>enableAttribution</span>();</pre>
<h1>Getting user feedback</h1>
<p>
  There are two ways of getting feedback from your users: Star rating dialog and
  Feedback widget.
</p>
<p>
  Star rating dialog allows users to give feedback as a rating from 1 to 5. The
  feedback widget allows to get the same 1 to 5 rating and also a text comment.
</p>
<h2>Feedback widget</h2>
<p>
  Feedback widget shows a server configured widget to your user devices.
</p>
<div class="img-container">
  <img src="https://count.ly/images/guide/c928493-feedback_widget.png">
</div>
<p>
  It's possible to configure any of the shown text fields and replace them with
  a custom string of your choice.
</p>
<p>
  In addition to a 1 to 5 rating, it is possible for users to leave a text comment
  and also leave an email in case the user would want some contact from the app
  developer.
</p>
<p>
  Trying to show the rating widget is a single call, but underneath is a two-step
  process. Before it is shown, the SDK tries to contact the server to get more
  information about the dialog. Therefore a network connection to it is needed.
</p>
<p>
  You can try to show the widget after you have initialized the SDK. To do that,
  you first have to get the widget ID from your server:
</p>
<div class="img-container">
  <img src="https://count.ly/images/guide/dee9bfc-feedback2.png">
</div>
<p>
  Using that you can call the function to show the widget popup:
</p>
<pre><code class="javascript">Countly.askForFeedback("5da0877c31ec7124c8bf398d", "Close");</code></pre>
<h2>Star rating dialog</h2>
<p>
  Star rating integration provides a dialog for getting user's feedback about the
  application. It contains a title, simple message explaining what it is for, a
  1-to-5 star meter for getting users rating and a dismiss button in case the user
  does not want to give a rating.
</p>
<p>
  This star-rating has nothing to do with Google Play Store ratings and reviews.
  It is just for getting brief feedback from users, to be displayed on the Countly
  dashboard. If the user dismisses star rating dialog without giving a rating,
  the event will not be recorded.
</p>
<p>
  Star-rating dialog's title, message and dismiss button text can be customized
  either through the init function or the SetStarRatingDialogTexts function. If
  you don't want to override one of those values, set it to "null".
</p>
<pre><code class="javascript">Countly.askForStarRating();</code></pre>
<p>Star rating dialog can be displayed in 2 ways:</p>
<ul>
  <li>Manually, by developer</li>
  <li>Automatically, depending on session count</li>
</ul>
<p>
  In order to display the Star rating dialog manually, you must call the ShowStarRating
  function. Optionally, you can provide callback functions. There is no limit on
  how many times star-rating dialog can be displayed manually.
</p>
<h1>Remote config</h1>
<p>
  Remote config allows you to modify how your app functions or looks by requesting
  key-value pairs from your Countly server. The returned values can be modified
  based on the user profile. For more details please see Remote Config documentation.
</p>
<h2>Automatic remote config download</h2>
<p>
  There are two ways of acquiring remote config data, by automatic download or
  manual request. By default, automatic remote config is disabled and therefore
  without developer intervention no remote config values will be requested.
</p>
<p>
  Automatic value download happens when the SDK is initiated or when the device
  ID is changed. To enable it, you have to call setRemoteConfigAutomaticDownload
  before init. As an optional value you can provide a callback to be informed when
  the request is finished.
</p>
<pre><code class="javascript">Countly.setRemoteConfigAutomaticDownload((result){
	print(result);
});</code></pre>
<p>
  If the callback returns a non-null value, then you can expect that the request
  failed and no values were updated.
</p>
<p>
  When doing an automatic update, all locally stored values are replaced with the
  ones received (all locally stored ones are deleted and in their place are put
  new ones). It is possible that a previously valid key returns no value after
  an update.
</p>
<h2>Manual remote config download</h2>
<p>
  There are three ways for manually requesting remote config update:
</p>
<ul>
  <li>Manually updating everything</li>
  <li>Manually updating specific keys</li>
  <li>Manually updating everything except specific keys</li>
</ul>
<p>
  Each of these requests also has a callback. If that returns a non-null value,
  the request encountered some error and failed.
</p>
<p>
  Functionally the manual update for everything <code>remoteConfigUpdate</code>
  is the same as the automatic update - replaces all stored values with the ones
  from the server (all locally stored ones are deleted and in their place are put
  new ones). The advantage is that you can make the request whenever it is desirable
  for you. It has a callback to let you know when it has finished.
</p>
<pre><code class="javascript">Countly.remoteConfigUpdate((result){
	print(result);
});</code></pre>
<p>
  You might want to update only specific key values. For that you need to call
  <code>updateRemoteConfigForKeysOnly</code> with a list of keys you want to be
  updated. That list is an array with string values of those keys. It has a callback
  to let you know when the request has finished.
</p>
<pre><code class="javascript">Countly.updateRemoteConfigForKeysOnly(["name"],(result){
	print(result);
});</code></pre>
<p>
  You might want to update all values except a few defined keys, for that call
  <code>updateRemoteConfigExceptKeys</code>. The key list is an array with string
  values of the keys. It has a callback to let you know when the request has finished.
</p>
<pre><code class="javascript">Countly.updateRemoteConfigExceptKeys(["url"],(result){
	print(result);
});</code></pre>
<p>
  When making requests with an "inclusion" or "exclusion" array, if those arrays
  are empty or null, they will function the same as a simple manual request and
  will update all values. This means that it will also erase all keys not returned
  by the server.
</p>
<h2>Getting remote config values</h2>
<p>
  To request a stored value, call getRemoteConfigValueForKey with the specified
  key. If it returns null then no value was found. The SDK has no knowledge of
  the returned value type and therefore returns an Object. The developer needs
  to cast it to the appropriate type. The returned values can also be a JSONArray,
  JSONObject or just a simple value like int.
</p>
<pre><code class="javascript">Countly.getRemoteConfigValueForKey("name", (result){
	print(result);
});</code></pre>
<h2>Clearing stored remote config values</h2>
<p>
  At some point you might want to erase all values downloaded from the server.
  To achieve that you need to call one function.
</p>
<pre><code class="javascript">Countly.remoteConfigClearValues((result){
	print(result);
});</code></pre>
<h1>User consent management</h1>
<p>
  <span>For compatibility with data protection regulations, such as GDPR, the Countly iOS SDK allows developers to enable/disable any feature at any time depending on user consent.</span>
  More information about GDPR
  <a href="https://blog.count.ly/countly-the-gdpr-how-worlds-leading-mobile-and-web-analytics-platform-can-help-organizations-5015042fab27">can be found here.</a>
</p>
<p>
  By default the requirement for consent is disabled. To enable it, you have to
  call <code>setRequiresConsent</code> with true, before initializing Countly.
</p>
<pre><code class="javascript">Countly.setRequiresConsent(true);</code></pre>
<p>
  By default no consent is given. That means that if no consent is enabled, Countly
  will not work and no network requests, related to features, will be sent. When
  the consent status of a feature is changed, that change will be sent to the Countly
  server.
</p>
<p>
  <span>The Countly SDK does not persistently store the status of given consents except push notifications. You are expected to handle receiving consent from end-users using proper UIs depending on your app's context. You are also expected to store them either locally or remotely. Following this step, you will need to call the<code>giveConsent</code> methods on each app launch, right after<code>Countly.init</code>&nbsp;depending on the permissions you managed to get from the end-users.</span>
</p>
<p>
  The ideal location for giving consent is after&nbsp;<span><code>Countly.init</code>&nbsp;and before&nbsp;<code>Countly.start()</code>. Consent for features can be given and revoked at any time, but if it is given after<code>Countly.start()</code>&nbsp;, some features might work partially.</span>
</p>
<p>
  If consent is removed, but the appropriate function can't be called before the
  app closes, it should be done at next app start so that any relevant server-side
  features could be disabled (like reverse geo ip for location)
</p>
<p>
  <span>Currently, available features with consent control are as follows</span>:
</p>
<ul>
  <li>
    sessions - tracking when, how often and how long users use your app
  </li>
  <li>events - allow sending custom events to the server</li>
  <li>views - allow tracking which views user visits</li>
  <li>location - allow sending location information</li>
  <li>crashes - allow tracking crashes, exceptions and errors</li>
  <li>
    attribution - allow tracking from which campaign did user come
  </li>
  <li>
    users - allow collecting/providing user information, including custom properties
  </li>
  <li>push - allow push notifications</li>
  <li>star-rating - allow sending their rating and feedback</li>
  <li>apm - allow application performance monitoring</li>
</ul>
<h2>Giving consents</h2>
<p>
  <span>To give consent for features, you can use&nbsp;the&nbsp;<code>giveConsent</code>method by passing the feature names&nbsp;</span><span>as an Array</span><span>:</span>
</p>
<pre><code class="javascript">Countly.giveConsent(["events", "views", "star-rating", "crashes"]);</code></pre>
<h2>Removing consents</h2>
<p>
  <span>If the end-user changes his/her mind about consents at a later time, you will need to reflect this in the Countly SDK using&nbsp;the&nbsp;<code>removeConsent</code></span><span>method:</span>
</p>
<pre><code class="javascript">Countly.removeConsent(["events", "views", "star-rating", "crashes"]);</code></pre>
<h2>Giving all consents</h2>
<p>
  <span>If you would like to give consent for all the features, you can use the&nbsp;</span><code>giveAllConsent</code><span>&nbsp;method:</span>
</p>
<pre><code class="javascript">Countly.giveAllConsent();</code></pre>
<h2>Removing all consents</h2>
<p>
  <span>If you would like to remove consent for all the features, you can use&nbsp;the&nbsp;<code>removeAllConsent</code></span><span>&nbsp;method:</span>
</p>
<pre><code class="javascript">Countly.removeAllConsent();</code></pre>
<h1>Troubleshooting</h1>
<div class="callout callout--info">
  <h3 class="callout__title">Warning about Java</h3>
  <p>
    Note: As per the new release, you will need Java 1.8 to bundle the application.
    You will need to update the CLASSPATH environment variable of Java and Javac
    to Java version 1.8
  </p>
</div>
<h1>Push notifications</h1>
<h2>Android setup</h2>
<p>
  Step 1: Hope you have created your flutter app, and installed countly_flutter
  package.
</p>
<p>
  Step 2: Make sure you have <code>google-services.json</code> from
  <a href="https://firebase.google.com/">https://firebase.google.com/</a>
</p>
<p>
  Step 3: Make sure the app package name and the
  <code>google-services.json</code> <code>package_name</code> matches.
</p>
<p>
  Step 4: Place the <code>google-services.json</code> file inside
  <code>android/app</code>
</p>
<p>
  Step 5: Add the following line in file
  <code>android/app/src/main/AndroidManifest.xml</code> inside
  <code>application</code> tag.
</p>
<pre><code class="xml">&lt;service android:name="ly.count.dart.countly_flutter.CountlyMessagingService"&gt;
    &lt;intent-filter&gt;
        &lt;action android:name="com.google.firebase.MESSAGING_EVENT" /&gt;
    &lt;/intent-filter&gt;
&lt;/service&gt;
</code></pre>
<p>
  Step 7: Use the latest version from this link
  <a href="https://firebase.google.com/support/release-notes/android#latest_sdk_versions">https://firebase.google.com/support/release-notes/android#latest_sdk_versions</a>
  and this link
  <a href="https://developers.google.com/android/guides/google-services-plugin">https://developers.google.com/android/guides/google-services-plugin</a>
</p>
<p>
  Step 6: Add the following line in file <code>android/build.gradle</code>
</p>
<pre><code class="JavaScript">buildscript {
    dependencies {
        classpath 'com.google.gms:google-services:4.3.2'
    }
}
</code></pre>
<p>
  Step 7: Add the following line in file <code>android/app/build.gradle</code>
</p>
<pre><code class="JavaScript">dependencies {
    implementation 'ly.count.android:sdk:20.04'
    implementation 'com.google.firebase:firebase-messaging:20.0.0'
}
// Add this at the bottom of the file
apply plugin: 'com.google.gms.google-services'
</code></pre>
<h2>iOS setup</h2>
<p>
  For iOS push notification please follow the instruction from this URL
  <a href="https://resources.count.ly/docs/countly-sdk-for-ios-and-os-x#section-push-notifications">https://resources.count.ly/docs/countly-sdk-for-ios-and-os-x#section-push-notifications</a>
</p>
<p>
  For Flutter you can find <code>CountlyNotificationService.m</code> file under
  <code>Pods/Pods/Countly/CountlyNotificationService.m</code>
</p>
<p>You can drag and drop the file from Pod to Compile Sources.</p>
<div class="img-container">
  <img src="https://count.ly/images/guide/d38dc91-Screenshot_2019-11-12_at_2.33.24_PM.png">
</div>
<h2>General setup</h2>
<p>
  First, when setting up push for the Flutter SDK, you would first select the push
  token mode. This would allow you to choose either test or production modes, push
  token mode should be set before init.
</p>
<pre><span>// Set messaging mode for push notifications</span><br>Countly.<span>pushTokenType</span>(Countly.<span>messagingMode</span>[<span>"TEST"</span>]);<span></span><span></span></pre>
<div class="callout callout--info">
  <p class="callout__title">
    <strong><span class="wysiwyg-font-size-large">Minimum Countly SDK Version</span></strong>
  </p>
  <p>
    This feature is only supported by the minimum SDK version 20.04.1.
  </p>
</div>
<p>
  You may want to listen to a callback of when a push notification is received.
  You would register to that like this:
</p>
<pre><span>// Set callback to receive push notifications</span><br>Countly.<span>onNotification</span>((String notification){<br>  print(<span>"The notification"</span>);<br>  print(notification);<br>});<span> </span></pre>
<p>
  When you are finally ready to initialise Countly push, you would call this:
</p>
<pre><span>// This method will ask for permission, enables push notification and send push token to countly server.;<br>Countly.askForNotificationPermission();<br></span></pre>