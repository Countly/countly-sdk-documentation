<p>
  This document will guide you through the process of Countly SDK installation
  and it applies to version 21.11.0
</p>
<div class="callout callout--info">
  <p class="callout__title">
    <span class="wysiwyg-font-size-large"><strong>Older documentation</strong></span>
  </p>
  <p>
    To access the documentation for version 20.11 and older, click
    <a href="/hc/en-us/articles/4409295642137" target="_self" rel="undefined">here.</a>
  </p>
</div>
<p>
  This document includes the necessary information for integrating Countly Flutter
  SDK in your application. Flutter SDK requires Android and iOS SDKs, hence all
  the features and limitations regarding those platforms also apply to Countly
  Flutter SDK.
</p>
<p>
  Countly is an open source SDK, you can take a look at our SDK code in the
  <a href="https://github.com/Countly/countly-sdk-flutter-bridge" target="_self" rel="undefined">Github repo</a>
</p>
<p>
  <strong>Supported Platforms:</strong> Countly SDK supports iOS and Android.
</p>
<p>
  Below you can see steps to download a Flutter example application:
</p>
<pre><code class="shell">git clone https://github.com/Countly/countly-sdk-flutter-bridge.git
cd countly-sdk-flutter-bridge/example
flutter pub get
flutter run</code></pre>
<p>
  This example application has all the methods mentioned in this documentation.
  It is a great way of understanding how different methods work, like events, custom
  user profiles and views.
</p>
<h1>Adding the SDK to the project</h1>
<p>
  Add this to your package's <code>pubspec.yaml</code> file:
</p>
<pre><code class="yaml">dependencies:
  countly_flutter:
    git: 
      url: https://github.com/Countly/countly-sdk-flutter-bridge.git
      ref: master
</code></pre>
<p>
  You can install packages from the command line with Flutter:
</p>
<pre><code class="shell">flutter pub get</code></pre>
<h1>SDK Integration</h1>
<h2>Minimal setup</h2>
<p>
  The shortest way to initiate the SDK if you want Countly SDK to take care of
  device ID seamlessly, use the code below. You can find your app key on your Countly
  dashboard, under the "Applications" menu item.
</p>
<pre><code class="JavaScript">Countly.isInitialized().then((bool isInitialized){
    if(!isInitialized){<br>      CountlyConfig config = CountlyConfig(SERVER_URL, APP_KEY);<br>      Countly.initWithConfig(config).then((value){
        Countly.start();
      }); // Initialize the countly SDK.
    }else{
      print("Countly: Already initialized.");
    }
  });</code></pre>
<p>
  For more information on how to acquire your application key (appKey) and server
  URL, check
  <a href="https://support.count.ly/hc/en-us/articles/900000908046-Getting-started-with-SDKs#acquiring-your-application-key-and-server-url" target="_self">here</a>
</p>
<p>
  To configure the SDK during init, a config object called "CountlyConfig" is used.
  Configuration is done by creating such an object and then calling it's provided
  function calls to enable functionality you need.<br>
  Click
  <a href="https://support.count.ly/hc/en-us/articles/360037944212-Flutter#sdk-config-parameters-explained" target="_self">here</a>
  for more detail about "CountlyConfig" functionalities.
</p>
<h2>Enable logging</h2>
<p>
  If logging is enabled then our SDK will print out debug messages about its internal
  state and encountered problems.
</p>
<p>
  We advise doing this while implementing Countly features in your application.
</p>
<pre><code class="JavaScript">CountlyConfig config = CountlyConfig(SERVER_URL, APP_KEY);<br>config.setLoggingEnabled(true);</code></pre>
<h2>Device ID</h2>
<p>
  When the SDK is initialized for the first time and no device ID is provided,
  a device ID will be generated by SDK.
</p>
<p>
  For iOS: the device ID generated by SDK is the Identifier For Vendor (IDFV)<br>
  For Android: the device ID generated by SDK is the OpenUDID
</p>
<p>
  You may provide your own custom device ID when initializing the SDK
</p>
<pre><code class="JavaScript">CountlyConfig config = CountlyConfig(SERVER_URL, APP_KEY);<br>config.setDeviceId(DEVICE_ID);</code></pre>
<h2>SDK data storage</h2>
<p>
  For iOS: SDK data is stored in Application Support Directory in file named "Countly.dat"<br>
  For Android: SDK data is stored in SharedPreferences. A SharedPreferences object
  points to a file containing key-value pairs and provides simple methods to read
  and write them.
</p>
<h1>Crash reporting</h1>
<p>
  This feature allows the Countly SDK to record crash reports of either encountered
  issues or exceptions which cause your application to crash. Those reports will
  be sent to your Countly server for further inspection.
</p>
<p>
  If a crash report can not be delivered to the server (e.g. no internet connection,
  unavailable server), then SDK stores the crash report locally in order to try
  again later.
</p>
<h2>Automatic crash handling</h2>
<p>
  If you want to enable automatic unhandled crash reporting, you need to call this
  before init:
</p>
<pre><code class="JavaScript">CountlyConfig config = CountlyConfig(SERVER_URL, APP_KEY);<br>config.enableCrashReporting()</code></pre>
<p>
  By doing that it will automatically catch all errors that are thrown from within
  the Flutter framework.
</p>
<p>
  <br>
  If you want to catch Dart errors, run your app inside a Zone and supply
  <code>Countly.recordDartError</code> to the <code>onError</code> parameter:
</p>
<pre><code class="JavaScript">void main() {<br>  runZonedGuarded&lt;Future&lt;void&gt;&gt;(() async {<br>    runApp(MyApp());<br>  }, Countly.recordDartError);<br>}</code></pre>
<h2>Automatic crash report segmentation</h2>
<p>
  You may add a key/value segment to crash reports. For example, you could set
  which specific library or framework version you used in your app. You may then
  figure out if there is any correlation between the specific library or another
  segment and the crash reports.
</p>
<p>
  The following call will add the provided segmentation to all recorded crashes.
  Use the following function for this purpose:
</p>
<pre><code class="JavaScript">CountlyConfig config = CountlyConfig(SERVER_URL, APP_KEY);<br>config.setCustomCrashSegment(Map&lt;String, Object&gt; segments);</code></pre>
<h2>Handled exceptions</h2>
<p class="p1">
  There are multiple ways you could report a handled exception/error to Countly.
</p>
<p class="p1">
  This call does not add a stacktrace automatically. If it is required, it should
  be provided to the function. A potential use case would be to
  <code>exception.toString()</code>
</p>
<pre><code class="JavaScript">Countly.logException(String exception, bool nonfatal, [Map&lt;String, Object&gt; segmentation])</code></pre>
<p>
  The issue is recorded with a provided Exception object. If no stacktrace is set,<code>StackTrace.current</code>
  will be used.
</p>
<pre><code class="JavaScript">Countly.logExceptionEx(Exception exception, bool nonfatal, {StackTrace stacktrace, Map&lt;String, Object&gt; segmentation})</code></pre>
<p class="p1">
  The exception/error is recorded through a string message. If no stack trace is
  provided, <code>StackTrace.current</code> will be used.
</p>
<pre><code class="JavaScript">Countly.logExceptionManual(String message, bool nonfatal, {StackTrace stacktrace, Map&lt;String, Object&gt; segmentation})</code></pre>
<p>
  Below are some examples that how to log handled/nonfatal and unhandled/fatal
  exceptions manually.
</p>
<p>
  <strong>1. Manually report exception</strong>
</p>
<pre><code class="JavaScript">bool nonfatal = true; // Set it false in case of fatal exception<br>// With Exception object
Countly.logExceptionEx(EXCEPTION_OBJECT, nonfatal);
<br>// With String message
Countly.logExceptionManual("MESSAGE_STRING", nonfatal);
</code></pre>
<p>
  <strong>2. Manually report exception with stack trace</strong>
</p>
<pre><code class="JavaScript">bool nonfatal = true; // Set it false in case of fatal exception<br>// With Exception object
Countly.logExceptionEx(EXCEPTION_OBJECT, nonfatal, stacktrace: STACK_TRACE_OBJECT);
<br>// With String message
Countly.logExceptionManual("MESSAGE_STRING", nonfatal, stacktrace: STACK_TRACE_OBJECT);
</code></pre>
<p>
  <strong>3. Manually report exception with segmentation</strong>
</p>
<pre><code class="JavaScript">bool nonfatal = true; // Set it false in case of fatal exception<br>// With Exception object
Countly.logExceptionEx(EXCEPTION_OBJECT, nonfatal, segmentation: {"_facebook_version": "0.0.1"});
<br>// With String message
Countly.logExceptionManual("MESSAGE_STRING", nonfatal, segmentation: {"_facebook_version": "0.0.1"});
</code></pre>
<p>
  <strong>4. Manually report exception with stack trace and segmentation</strong>
</p>
<pre><code class="JavaScript">bool nonfatal = true; // Set it false in case of fatal exception<br>// With Exception object
Countly.logExceptionEx(EXCEPTION_OBJECT, nonfatal, STACK_TRACE_OBJECT, {"_facebook_version": "0.0.1"});
<br>// With String message
Countly.logExceptionManual("MESSAGE_STRING", nonfatal, STACK_TRACE_OBJECT, {"_facebook_version": "0.0.1"});
</code></pre>
<h2>Crash breadcrumbs</h2>
<p>
  Throughout your app, you can leave crash breadcrumbs which would describe previous
  steps that were taken in your app before the crash. After a crash happens, they
  will be sent together with the crash report.
</p>
<p>The following function call adds a crash breadcrumb:</p>
<pre><code class="JavaScript">Countly.addCrashLog(String logs)</code></pre>
<h1>Events</h1>
<p>
  <a href="http://resources.count.ly/docs/custom-events">Event</a> is any type
  of action that you can send to a Countly instance, e.g purchase, settings changed,
  view enabled and so. This way it's possible to get much more information from
  your application compared to what is sent from Flutter SDK to Countly instance
  by default.
</p>
<p>
  Here are the detail about properties which we can use with event:
</p>
<ul>
  <li>
    <code>key</code> identifies the event
  </li>
  <li>
    <code>count</code> is the number of times this event occurred
  </li>
  <li>
    <code>sum</code> is an overall numerical data set tied to an event. For example,
    total amount of in-app purchase event.
  </li>
  <li>
    <code class="JavaScript">duration</code> is used to record and track the
    duration of events.
  </li>
  <li>
    <code>segmentation</code> is a key-value pairs, we can use
    <code>segmentation</code> to track additional information. The only valid
    data types are: "String", "Integer", "Double" and "Boolean". All other types
    will be ignored
  </li>
</ul>
<div class="callout callout--info">
  <p class="callout__title">
    <strong><span class="wysiwyg-font-size-large">Data passed should be in UTF-8</span></strong>
  </p>
  <p>
    All data passed to the Countly server via SDK or API should be in UTF-8.
  </p>
</div>
<h2>Recording events</h2>
<p>
  We will be recording a <strong>purchase</strong> event. Here is a quick summary
  of what information each usage will provide us:
</p>
<ul>
  <li>
    Usage 1: how many times a <strong>purchase</strong> event occurred.
  </li>
  <li>
    Usage 2: how many times a <strong>purchase</strong> event occurred + the
    total amount of those purchases.
  </li>
  <li>
    Usage 3: how many times a <strong>purchase</strong> event occurred + which
    countries and application versions those purchases were made from.
  </li>
  <li>
    Usage 4: how many times a <strong>purchase</strong> event occurred + the
    total amount both of which are also available segmented into countries and
    application versions.
  </li>
  <li>
    Usage 5: how many times <strong>purchase</strong> event occurred + the total
    amount both of which are also available segmented into countries and application
    versions + the total duration of those events (under Timed Events topic below)
  </li>
</ul>
<p>
  <span class="wysiwyg-font-size-large">1. Event key and count</span>
</p>
<pre><code class="JavaScript">// example for sending basic event
var event = {
  "key": "Basic Event",
  "count": 1
};
Countly.recordEvent(event);</code></pre>
<p>
  <span class="wysiwyg-font-size-large">2. Event key, count and sum</span>
</p>
<pre><code class="JavaScript">// example for event with sum
var event = {
  "key": "Event With Sum",
  "count": 1,
  "sum": "0.99",
};
Countly.recordEvent(event);
</code></pre>
<p>
  <span class="wysiwyg-font-size-large">3. Event key and count with segmentation(s)</span>
</p>
<pre><code class="JavaScript">// example for event with segment
var event = {
  "key": "Event With Segment",
  "count": 1
};
event["segmentation"] = {
  "Country": "Germany",
  "Age": "28"
};
Countly.recordEvent(event);
</code></pre>
<p>
  <span class="wysiwyg-font-size-large">4. Event key, count and sum with segmentation(s)</span>
</p>
<pre><code class="JavaScript">
// example for event with segment and sum
var event = {
  "key": "Event With Sum And Segment",
  "count": 1,
  "sum": "0.99"
};
event["segmentation"] = {
  "Country": "Germany",
  "Age": "28"
};
Countly.recordEvent(event);
</code></pre>
<p>
  <span class="wysiwyg-font-size-large">5. Event key, count, sum and duration with segmentation(s)</span>
</p>
<pre><code class="JavaScript">
// example for event with segment and sum
var event = {
  "key": "Event With Sum And Segment",
  "count": 1,
  "sum": "0.99",
  "duration": "0"
};
event["segmentation"] = {
  "Country": "Germany",
  "Age": "28"
};
Countly.recordEvent(event);
</code></pre>
<h2>Timed events</h2>
<p>
  It's possible to create timed events by defining a start and a stop moment
</p>
<p>
  <span class="wysiwyg-font-size-large">1.Timed event with key</span>
</p>
<pre><code class="JavaScript">// Basic event
Countly.startEvent("Timed Event");
Timer timer = Timer(new Duration(seconds: 5), () {
    Countly.endEvent({ "key": "Timed Event" });
});
</code></pre>
<p>
  <span class="wysiwyg-font-size-large">2.Timed event with key and sum</span>
</p>
<pre><code class="JavaScript">// Event with sum
Countly.startEvent("Timed Event With Sum");
Timer timer = Timer(new Duration(seconds: 5), () {
    Countly.endEvent({ "key": "Timed Event With Sum", "sum": "0.99" });
});
</code></pre>
<p>
  <span class="wysiwyg-font-size-large">3.Timed event with key, count and segmentation</span>
</p>
<pre><code class="JavaScript">// Event with segment
Countly.startEvent("Timed Event With Segment");
Timer timer = Timer(new Duration(seconds: 5), () {
    var event = {
        "key": "Timed Event With Segment",
        "count": 1,
    };
    event["segmentation"] = {
        "Country": "Germany",
        "Age": "28"
    };
    Countly.endEvent(event);
});</code></pre>
<p>
  <span class="wysiwyg-font-size-large">4.Timed event with key, count, sum and segmentation</span>
</p>
<pre><code class="JavaScript">// Event with Segment, sum and count
Countly.startEvent("Timed Event With Segment, Sum and Count");
Timer timer = Timer(new Duration(seconds: 5), () {
    var event = {
        "key": "Timed Event With Segment, Sum and Count",
        "count": 1,
        "sum": "0.99"
    };
    event["segmentation"] = {
        "Country": "Germany",
        "Age": "28"
    };
    Countly.endEvent(event);
});</code></pre>
<h1>Sessions</h1>
<h2>Automatic session tracking</h2>
<p>
  To start recording an automatic session tracking you would call:
</p>
<pre><code class="JavaScript">Countly.start();</code></pre>
<p>
  <code class="JavaScript">Countly.start();</code> will handle the start session,
  update session and end session automatically.<br>
  This is how it works:
</p>
<ul>
  <li>
    <strong>Start/Begin session Request:</strong> It is sent on
    <code class="JavaScript">Countly.start();</code> call and when the app comes
    back to the foreground from the background, and it includes basic metrics.
  </li>
  <li>
    <strong>Update Session Request:</strong> It automatically sends a periodical
    (60 sec by default) update session request while the app is in the foreground.
  </li>
  <li>
    <strong>End Session Request:</strong> It is sent at the end of a session
    when the app goes to the background or terminates.
  </li>
</ul>
<p>
  If you want to end automatic session tracking you would call:
</p>
<pre><code class="JavaScript">Countly.stop();</code></pre>
<h2 id="manual-sessions" class="anchor-heading">Manual sessions</h2>
<p>
  Sometimes it might be preferable to control the session manually instead of relying
  on the SDK.
</p>
<p>It can be enabled during init with:</p>
<pre><code class="JavaScript">CountlyConfig config = CountlyConfig(SERVER_URL, APP_KEY);</code><br>config.enableManualSessionHandling();</pre>
<p>Afterwards it is up to the implementer to make calls to:</p>
<ul>
  <li>Begin session</li>
  <li>
    Update session duration. By default, you would call this every 60 seconds
    after beginning a session so that it is not closed server side. If you would
    want to increase that duration, you would have to increase the "<span>Maximal Session Duration" in your server API configuration.</span>
  </li>
  <li>End session (also updates duration)</li>
</ul>
<p>The approprate call to do that are:</p>
<pre>Countly.beginSession();<br>Countly.updateSession();<br>Countly.endSession();</pre>
<h1>View tracking</h1>
<h2>Manual view recording</h2>
<p>
  You can manually add your own views in your application, and each view will be
  visible under Views menu item. Below you can see two examples of sending a view
  using <code>Countly.recordview</code> function.
</p>
<pre><code class="JavaScript">// record a view on your application
Countly.recordView("HomePage");
Countly.recordView("Dashboard");</code></pre>
<p>
  While manually tracking views, you may want to add custom segmentation to them.
</p>
<pre><code class="JavaScript">Map&lt;String, Object&gt; segments = {<br>  "Cats": 123,<br>  "Moons": 9.98,<br>  "Moose": "Deer"<br>};<br>Countly.recordView("HomePage", segments);</code></pre>
<h1>Device ID management</h1>
<p>
  A device ID is a unique identifier for your users. You may specify the device
  ID yourself or allow the SDK to generate it. When providing one yourself, keep
  in mind that it has to be unique for all users. Some potential sources for such
  an id could be the username, email or some other internal ID used by your other
  systems.
</p>
<h2>Device ID generation</h2>
<p>
  When the SDK is initialized for the first time with no device ID, then SDK will
  generate a device ID.
</p>
<p>
  Here are the underlying mechanisms used to generate that value for some platforms:
</p>
<p>
  For iOS: the device ID generated by SDK is the Identifier For Vendor (IDFV)<br>
  For Android: the device ID generated by SDK is the OpenUDID
</p>
<h2>Changing the Device ID</h2>
<p>You may configure/change the device ID anytime using:</p>
<pre><code class="JavaScript">Countly.changeDeviceId(DEVICE_ID, ON_SERVER);</code></pre>
<p>
  You may either allow the device to be counted as a new device or merge existing
  data on the server. If the<code>onServer</code> bool is set to
  <code>true</code>, the old device ID on the server will be replaced with the
  new one, and data associated with the old device ID will be merged automatically.<br>
  Otherwise, if <code>onServer</code> bool is set to <code>false</code>, the device
  will be counted as a new device on the server.
</p>
<h2>Temporary Device ID</h2>
<p>
  You may use a temporary device ID mode for keeping all requests on hold until
  the real device ID is set later.
</p>
<p>
  You can enable temporary device ID when initializing the SDK:
</p>
<pre><code class="JavaScript">Countly.init(SERVER_URL, APP_KEY, Countly.deviceIDType["TemporaryDeviceID"])</code></pre>
<p>To enable a temporary device ID after init, you would call:</p>
<pre><code class="JavaScript">Countly.changeDeviceId(Countly.deviceIDType["TemporaryDeviceID"], ON_SERVER);</code></pre>
<p>
  <strong>Note:</strong> When passing <code>TemporaryDeviceID</code> for
  <code>deviceID</code> parameter, argument for <code>onServer</code>parameter
  does not matter.
</p>
<p>
  As long as the device ID value is <code>TemporaryDeviceID</code>, the SDK will
  be in temporary device ID mode and all requests will be on hold, but they will
  be persistently stored.
</p>
<p>
  When in temporary device ID mode, method calls for presenting feedback widgets
  and updating remote config will be ignored.
</p>
<p>
  Later, when the real device ID is set using
  <code>Countly.changeDeviceId(DEVICE_ID, ON_SERVER);</code> method, all requests
  which have been kept on hold until that point will start with the real device
  ID
</p>
<h2>Retrieving current device ID</h2>
<p>
  You may want to see what device id Countly is assigning for the specific device.
  For that, you may use the following call:
</p>
<pre><code class="JavaScript">String currentDeviceId = Countly.getCurrentDeviceId();</code></pre>
<p>
  <span>You can use </span><code>getDeviceIDType</code><span>&nbsp;method which returns a </span><code>DeviceIDType</code><span> to get the current device ID type. The id type is an enum with the possible values of: </span>
</p>
<ul>
  <li>
    <span>"DEVELOPER_SUPPLIED" - device ID was supplied by the host app</span>
  </li>
  <li>
    <span>"SDK_GENERATED" - device ID was generated by the SDK</span>
  </li>
  <li>
    <span>"TEMPORARY_ID" - the SDK is in temporary device ID mode</span>
  </li>
</ul>
<pre>DeviceIdType? deviceIdType = await Countly.getDeviceIDType();</pre>
<h1>Push notifications</h1>
<h2>Integration</h2>
<h3>Android setup</h3>
<p>
  Step 1: For FCM credentials setup please follow the instruction from this URL
  <a class="c-link" href="https://support.count.ly/hc/en-us/articles/360037754031-Android#getting-fcm-credentials" target="_blank" rel="noopener noreferrer" data-stringify-link="https://support.count.ly/hc/en-us/articles/360037754031-Android#getting-fcm-credentials" data-sk="tooltip_parent">https://support.count.ly/hc/en-us/articles/360037754031-Android#getting-fcm-credentials</a>.
</p>
<p>
  Step 2: Make sure you have <code>google-services.json</code> from
  <a href="https://firebase.google.com/">https://firebase.google.com/</a>
</p>
<p>
  Step 3: Make sure the app package name and the
  <code>google-services.json</code> <code>package_name</code> matches.
</p>
<p>
  Step 4: Place the <code>google-services.json</code> file inside
  <code>android/app</code>
</p>
<p>
  Step 5: Add the following line in file
  <code>android/app/src/main/AndroidManifest.xml</code> inside
  <code>application</code> tag.
</p>
<pre><code class="xml">&lt;service android:name="ly.count.dart.countly_flutter.CountlyMessagingService"&gt;
    &lt;intent-filter&gt;
        &lt;action android:name="com.google.firebase.MESSAGING_EVENT" /&gt;
    &lt;/intent-filter&gt;
&lt;/service&gt;
</code></pre>
<p>
  Step 7: Use the latest version from this link
  <a href="https://firebase.google.com/support/release-notes/android#latest_sdk_versions">https://firebase.google.com/support/release-notes/android#latest_sdk_versions</a>
  and this link
  <a href="https://developers.google.com/android/guides/google-services-plugin">https://developers.google.com/android/guides/google-services-plugin</a>
</p>
<p>
  Step 6: Add the following line in file <code>android/build.gradle</code>
</p>
<pre><code class="JavaScript">buildscript {
    dependencies {
        classpath 'com.google.gms:google-services:4.3.2'
    }
}
</code></pre>
<p>
  Step 7: Add the following line in file <code>android/app/build.gradle</code>
</p>
<pre><code class="JavaScript">dependencies {
    implementation 'ly.count.android:sdk:20.04'
    implementation 'com.google.firebase:firebase-messaging:20.0.0'
}
// Add this at the bottom of the file
apply plugin: 'com.google.gms.google-services'
</code></pre>
<h3>iOS setup</h3>
<p>
  By default push notification is enabled for iOS, to disable you need to call
  <code>disablePushNotifications</code> method:
</p>
<pre><code class="JavaScript">// // Disable push notifications feature for iOS, by default it is enabled.
Countly.disablePushNotifications();</code></pre>
<p>
  For iOS push notification please follow the instruction from this URL
  <a href="https://resources.count.ly/docs/countly-sdk-for-ios-and-os-x#section-push-notifications">https://resources.count.ly/docs/countly-sdk-for-ios-and-os-x#section-push-notifications</a>
</p>
<p>
  For Flutter you can find <code>CountlyNotificationService.h/m</code> file under
  <code>Pods/Development Pods/Countly/{PROJECT_NAME}/ios/.symlinks/plugins/countly_flutter/ios/Classes/CountlyiOS/CountlyNotificationService.h/m</code><br>
  <br>
  <strong>Pro Tips to find the files from deep hierarchy:<br></strong>
</p>
<ul>
  <li>
    You can filter the files in the navigator using a shortcut ⌥⌘J (Option-Command-J),
    in the filter box type "CountlyNotificationService" and it will show the
    related files only.
  </li>
  <li>
    You can find the file using the shortcut ⇧⌘O (Shift-Command-O) and then navigate
    to that file using the shortcut ⇧⌘J (Shift-Command-J)<br>
    <br>
  </li>
</ul>
<p>You can drag and drop the file from Pod to Compile Sources.</p>
<div class="img-container">
  <img src="/hc/article_attachments/900005820306/Flutter_iOS_Notifications.png" alt="Flutter_iOS_Notifications.png">
</div>
<h2>Enabling push</h2>
<p>
  First, when setting up push for the Flutter SDK, you would first select the push
  token mode. This would allow you to choose either test or production modes, push
  token mode should be set before init.
</p>
<pre><code class="JavaScript">// Set messaging mode for push notifications
Countly.pushTokenType(Countly.messagingMode["TEST"]);</code></pre>
<p>
  When you are finally ready to initialise Countly push, you would call this:
</p>
<pre><code class="JavaScript">// This method will ask for permission, enables push notification and send push token to countly server.
Countly.askForNotificationPermission();</code></pre>
<h2>Handling push callbacks</h2>
<p>
  To register a Push Notification callback after initializing the SDK, use the
  method below.
</p>
<pre>Countly.onNotification((String notification) {<br>   print(notification);<br>});</pre>
<p>
  In order to listen to notification receive and click events, Place below code
  in <code>AppDelegate.swift</code>&nbsp;
</p>
<p>Add header files</p>
<pre><code class="JavaScript">import countly_flutter
</code></pre>
<p>Add these methods:</p>
<pre><code class="JavaScript">// Required for the notification event. You must call the completion handler after handling the remote notification.
func application(application: UIApplication,  didReceiveRemoteNotification userInfo: [NSObject : AnyObject],  fetchCompletionHandler completionHandler: (UIBackgroundFetchResult) -&gt; Void) {
    CountlyFlutterPlugin.onNotification(userInfo);
    completionHandler(.newData);

}

@available(iOS 10.0, \*)
override func userNotificationCenter(_ center: UNUserNotificationCenter, willPresent notification: UNNotification, withCompletionHandler completionHandler: @escaping (_ options: UNNotificationPresentationOptions) -&gt; Void) {

    //Called when a notification is delivered to a foreground app.

    let userInfo: NSDictionary = notification.request.content.userInfo as NSDictionary
    CountlyFlutterPlugin.onNotification(userInfo as? [AnyHashable : Any])

}

@available(iOS 10.0, \*)
override func userNotificationCenter(\_ center: UNUserNotificationCenter, didReceive response: UNNotificationResponse, withCompletionHandler completionHandler: @escaping () -&gt; Void) {

    // Called to let your app know which action was selected by the user for a given notification.
    let userInfo: NSDictionary = response.notification.request.content.userInfo as NSDictionary
    // print("\(userInfo)")
    CountlyFlutterPlugin.onNotification(userInfo as? [AnyHashable : Any])

}
</code></pre>
<h1>User Location</h1>
<p>
  Countly allows you to send geolocation-based push notifications to your users.
  By default, the Countly Server uses the GeoIP database to deduce a user's location.
</p>
<h2>Set User Location</h2>
<p>
  If your app has a different way of detecting location, you may send this information
  to the Countly Server by using the <code>setLocation</code> of&nbsp;
  <code>CountlyConfig</code> during init or<code>setUserLocation</code> method
  after init.
</p>
<p>
  When setting user location information, you would be setting these values:
</p>
<ul>
  <li>
    <code>countryCode</code> a string in ISO 3166-1 alpha-2 format country code
  </li>
  <li>
    <code>city</code> a string specifying city name
  </li>
  <li>
    <code>location</code> a string comma-separated latitude and longitude
  </li>
  <li>
    <code>IP</code> a string specifying an IP address in IPv4 or IPv6 formats
  </li>
</ul>
<p>
  <span>All values are optional, but at least one should be set.</span>
</p>
<pre><code class="JavaScript">// Example for setLocation
CountlyConfig config = CountlyConfig(SERVER_URL, APP_KEY);<br>config.setLocation(country_code: 'TR', city: 'Istanbul', gpsCoordinates: '41.0082,28.9784', ipAddress: '10.2.33.12')</code></pre>
<p>
  Geolocation recording methods may also be called at any time after the Countly
  SDK has started.<br>
  To do so, use the <code>setUserLocation</code> method as shown below.
</p>
<pre><code class="JavaScript">// Example for setUserLocation
Countly.setUserLocation(countryCode: 'TR', city: 'Istanbul', gpsCoordinates: '41.0082,28.9784', ipAddress: '10.2.33.12');
</code></pre>
<h2>Disable Location</h2>
<p>
  To erase any cached location data from the device and stop further location tracking,
  use the following method. Note that if after disabling location, the
  <code>setUserLocation</code> is called with any non-null value, tracking will
  resume.
</p>
<pre><code class="JavaScript">//disable location tracking
Countly.disableLocation();</code></pre>
<h1>Remote config</h1>
<p>
  Remote config allows you to modify how your app functions or looks by requesting
  key-value pairs from your Countly server. The returned values can be modified
  based on the user profile. For more details please see Remote Config documentation.
</p>
<h2>Automatic remote config</h2>
<p>
  There are two ways of acquiring remote config data, by automatic download or
  manual request. By default, automatic remote config is disabled and therefore
  without developer intervention no remote config values will be requested.
</p>
<p>
  Automatic value download happens when the SDK is initiated or when the device
  ID is changed. To enable it, you have to call
  <code>setRemoteConfigAutomaticDownload</code> before init. As an optional value
  you can provide a callback to be informed when the request is finished.
</p>
<pre><code class="JavaScript">CountlyConfig config = CountlyConfig(SERVER_URL, APP_KEY);<br>config.setRemoteConfigAutomaticDownload(true, (error) {<br>   print(error);<br>});</code></pre>
<p>
  If the callback returns a non-null value, then you can expect that the request
  failed and no values were updated.
</p>
<p>
  When doing an automatic update, all locally stored values are replaced with the
  ones received (all locally stored ones are deleted and in their place are put
  new ones). It is possible that a previously valid key returns no value after
  an update.
</p>
<h2>Manual remote config</h2>
<p>
  There are three ways for manually requesting remote config update:
</p>
<ul>
  <li>Manually updating everything</li>
  <li>Manually updating specific keys</li>
  <li>Manually updating everything except specific keys</li>
</ul>
<p>
  Each of these requests also has a callback. If that returns a non-null value,
  the request encountered some error and failed.
</p>
<p>
  Functionally the manual update for everything <code>remoteConfigUpdate</code>
  is the same as the automatic update - replaces all stored values with the ones
  from the server (all locally stored ones are deleted and in their place are put
  new ones). The advantage is that you can make the request whenever it is desirable
  for you. It has a callback to let you know when it has finished.
</p>
<pre><code class="JavaScript">Countly.remoteConfigUpdate((result){
  print(result);
});</code></pre>
<p>
  You might want to update only specific key values. For that you need to call
  <code>updateRemoteConfigForKeysOnly</code> with a list of keys you want to be
  updated. That list is an array with string values of those keys. It has a callback
  to let you know when the request has finished.
</p>
<pre><code class="JavaScript">Countly.updateRemoteConfigForKeysOnly(["name"],(result){
  print(result);
});</code></pre>
<p>
  You might want to update all values except a few defined keys, for that call
  <code>updateRemoteConfigExceptKeys</code>. The key list is an array with string
  values of the keys. It has a callback to let you know when the request has finished.
</p>
<pre><code class="JavaScript">Countly.updateRemoteConfigExceptKeys(["url"],(result){
  print(result);
});</code></pre>
<p>
  When making requests with an "inclusion" or "exclusion" array, if those arrays
  are empty or null, they will function the same as a simple manual request and
  will update all values. This means that it will also erase all keys not returned
  by the server.
</p>
<h2>Getting remote config values</h2>
<p>
  To request a stored value, call getRemoteConfigValueForKey with the specified
  key. If it returns null then no value was found. The SDK has no knowledge of
  the returned value type and therefore returns an Object. The developer needs
  to cast it to the appropriate type. The returned values can also be a JSONArray,
  JSONObject or just a simple value like int.
</p>
<pre><code class="JavaScript">Countly.getRemoteConfigValueForKey("name", (result){
  print(result);
});</code></pre>
<h2>Clearing stored remote config values</h2>
<p>
  At some point you might want to erase all values downloaded from the server.
  To achieve that you need to call one function.
</p>
<pre><code class="JavaScript">Countly.remoteConfigClearValues((result){
  print(result);
});</code></pre>
<h1>User feedback</h1>
<p>
  There are a couple ways of receiving feedback from your users: star-rating dialog,
  the rating widget and the feedback widgets (survey, nps).
</p>
<p>
  Star-rating dialog allows users to give feedback as a rating from 1 to 5. The
  rating widget allows users to rate using the same 1 to 5 rating system as well
  as leave a text comment. Feedback widgets (survey, nps) allow for even more textual
  feedback from users.
</p>
<h2>Star rating dialog</h2>
<p>
  Star rating integration provides a dialog for getting user's feedback about the
  application. It contains a title, simple message explaining what it is for, a
  1-to-5 star meter for getting users rating and a dismiss button in case the user
  does not want to give a rating.
</p>
<p>
  This star-rating has nothing to do with Google Play Store ratings and reviews.
  It is just for getting brief feedback from users, to be displayed on the Countly
  dashboard. If the user dismisses star rating dialog without giving a rating,
  the event will not be recorded.
</p>
<pre><code class="JavaScript">Countly.askForStarRating();</code></pre>
<p>
  The star-rating dialog's title, message, and dismiss button text may be customized
  either through the following functions:
</p>
<pre><code class="JavaScript">CountlyConfig config = CountlyConfig(SERVER_URL, APP_KEY);
config.setStarRatingTextTitle("Custom title"); // Only available for Android
config.setStarRatingTextMessage("Custom message");
config.setStarRatingTextDismiss("Custom message"); // Only available for Android</code></pre>
<h2>Rating widget</h2>
<p>
  Feedback widget shows a server configured widget to your user devices.
</p>
<div class="img-container">
  <img src="/hc/article_attachments/9519364331417/001.png" alt="001.png">
</div>
<p>
  It's possible to configure any of the shown text fields and replace them with
  a custom string of your choice.
</p>
<p>
  In addition to a 1 to 5 rating, it is possible for users to leave a text comment
  and also leave an email in case the user would want some contact from the app
  developer.
</p>
<p>
  Trying to show the rating widget is a single call, but underneath is a two-step
  process. Before it is shown, the SDK tries to contact the server to get more
  information about the dialog. Therefore a network connection to it is needed.
</p>
<p>
  You can try to show the widget after you have initialized the SDK. To do that,
  you first have to get the widget ID from your server:
</p>
<div class="img-container">
  <img src="/hc/article_attachments/9519388544793/002.png" alt="002.png">
</div>
<p>
  Using that you can call the function to show the widget popup:
</p>
<pre><code class="JavaScript">Countly.presentRatingWidgetWithID(RATING_WIDGET_ID, closeButtonText: "close", ratingWidgetCallback: (error) {<br>if(error != null) {<br>   print(error);<br>}<br>});</code></pre>
<p>
  <code class="JavaScript">closeButtonText</code> and
  <code class="JavaScript">ratingWidgetCallback</code> are optional.
</p>
<h2>Feedback widget</h2>
<p>
  It is possible to display 2 kinds of Surveys widgets:
  <a href="https://support.count.ly/hc/en-us/articles/900003407386-NPS-Net-Promoter-Score-" target="_blank" rel="noopener">NPS</a>
  and
  <a href="https://support.count.ly/hc/en-us/articles/900004337763-Surveys" target="_blank" rel="noopener">Surveys</a>.
  Both widgets are shown as webviews and they both use the same code methods.
</p>
<p>
  Before any Surveys widget can be shown, you need to create them in your Countly
  Dashboard.
</p>
<p>
  When the widgets are created, you need to use 2 calls in your SDK: one to get
  all available widgets for a user and another to display a chosen widget.
</p>
<p>To get your available widget list, use the call below.</p>
<pre><code class="JavaScript">FeedbackWidgetsResponse feedbackWidgetsResponse = await Countly.getAvailableFeedbackWidgets() ;</code></pre>
<p>
  From the callback you would get
  <code class="JavaScript">FeedbackWidgetsResponse</code> objec which contains
  the list of all available widgets that apply to the current device id.
</p>
<p>The objects in the returned list look like this:</p>
<pre><code class="JavaScript">class CountlyPresentableFeedback {<br>    public String widgetId;<br>    public String type;<br>    public String name;<br>}</code></pre>
<p>
  To determine what kind of widget that is, check the "type" value. The potential
  values are <code>"survey"</code> and <code>"nps"</code>.
</p>
<p>
  Then use the widget type and description (which is the same as provided in the
  Dashboard) to decide which widget to show.
</p>
<p>
  After you have decided which widget you want to display, call the function below.
</p>
<p>
  You would then use the widget type and description (which is the same as provided
  in the dashboard) to decide which widget to show.
</p>
<p>
  After you have decided which widget you want to display, you would provide that
  object to the following function:
</p>
<pre><code class="JavaScript">await Countly.presentFeedbackWidget(widgets.first, 'Close', widgetShown: () {<br>   print('Widget Appeared');<br>}, widgetClosed: () {<br>   print('Widget Dismissed');<br>});</code></pre>
<p>
  <code class="JavaScript">widgetShown</code> and
  <code class="JavaScript">widgetClosed</code> are optional callbacks, you can
  pass these callbacks if you want to perform some actions when widget appear or
  dismiss.
</p>
<h2>Feedback widget manual reporting</h2>
<p>
  There might be some usecases where you might to use the native UI or a custom
  UI you have created instead of our webview solution. In those cases you would
  have to request all the widget related information and then report the result
  manually.
</p>
<p>
  For a sample integration, have a look at our sample app in the repo.
</p>
<p>
  First you would need to retrieve the available widget list with the previously
  mentioned <code>getAvailableFeedbackWidgets</code> call. After that you would
  have a list of possible <code>CountlyPresentableFeedback</code> objects. You
  would pick the one widget you would want to display.
</p>
<p>
  Having the <code>CountlyPresentableFeedback</code> object of the widget you would
  want to display, you could use the '<code class="JavaScript">getFeedbackWidgetData</code>'&nbsp;
  mehtod to retrieve the widget information with an optional 'onFinished' callback.<br>
  In case you want to use with callback then you can call '<code class="JavaScript">getFeedbackWidgetData</code>'
  in this way:
</p>
<pre><code class="JavaScript">Countly.getFeedbackWidgetData(chosenWidget, onFinished: (retrievedWidgetData, error) {<br>if (error == null) {<br>}<br>});</code></pre>
<p>
  If you want to use it without a callback then you can call '<code class="JavaScript">getFeedbackWidgetData</code>'
  in this way:
</p>
<pre><code class="JavaScript">List result = await Countly.getFeedbackWidgetData(chosenWidget) {<br>    error = result[1];<br>    if(error == null) {<br>       Map&lt;String, dynamic&gt; retrievedWidgetData = result[0];<br>    }<br>}</code></pre>
<p>
  <code>retrievedWidgetData</code> would contain a Map with all of the required
  information to present the widget yourself.
</p>
<p>
  After you have collected the required information from your users, you would
  package the responses into a <code>Map&lt;String, Object&gt;</code> and then
  use it, the widgetInformation and the widgetData to report the feedback result
  with the following call:
</p>
<pre><code class="JavaScript">//this contains the reported results
Map&lt;String, Object&gt; reportedResult = {};

//
// You would fill out the results here. That step is not displayed in this sample
//

//report the results to the SDK
Countly.reportFeedbackWidgetManually(chosenWidget, retrievedWidgetData , reportedResult);
</code></pre>
<p>
  If the user would have closed the widget, you would report that by passaing a
  "null" reportedResult.
</p>
<h1>User Profiles</h1>
<p>
  In order to set a user profile, use the code snippet below. After you send user
  data, it can be viewed under the User Profiles menu.
</p>
<p>
  Note that this feature is available only for Enterprise Edition.
</p>
<pre><code class="JavaScript">// example for setting user data
Map&lt;String, Object&gt; options = {
    "name": "Nicola Tesla",
    "username": "nicola",
    "email": "info@nicola.tesla",
    "organization": "Trust Electric Ltd",
    "phone": "+90 822 140 2546",
    "picture": "http://images2.fanpop.com/images/photos/3300000/Nikola-Tesla-nikola-tesla-3365940-600-738.jpg",
    "picturePath": "",
    "gender": "M", // "F"
    "byear": "1919",
};
Countly.setUserData(options);</code></pre>
<p>
  In order to modify a user's data (e.g increment, etc), the following code sample
  can be used.
</p>
<h2>Modifying custom data</h2>
<p>
  Additionally, you can do different manipulations on your custom data values,
  like increment current value on the server or store an array of values under
  the same property.
</p>
<p>Below is the list of available methods:</p>
<pre><code class="JavaScript">
//set one custom properties
Countly.setProperty("setProperty", "My Property");
//increment used value by 1
Countly.increment("increment");
//increment used value by provided value
Countly.incrementBy("incrementBy", 10);
//multiply value by provided value
Countly.multiply("multiply", 20);
//save maximal value
Countly.saveMax("saveMax", 100);
//save minimal value
Countly.saveMin("saveMin", 50);
//set value if it does not exist
Countly.setOnce("setOnce", 200);

//insert value to array of unique values
Countly.pushUniqueValue("type", "morning");;
//insert value to array which can have duplocates
Countly.pushValue("type", "morning");
//remove value from array
Countly.pullValue("type", "morning");
</code></pre>
<h1>Application Performance Monitoring</h1>
<p>
  This SDK provides a few mechanisms for APM. To start using them you would first
  need to enable this feature and give the required consent if it was required.
</p>
<pre><code class="JavaScript">CountlyConfig config = CountlyConfig(SERVER_URL, APP_KEY);<br>config</code>.setRecordAppStartTime(true); // Enable APM features, which includes the recording of app start time.</pre>
<p>
  While using APM calls, you have the ability to provide trace keys by which you
  can track those parameters in your dashboard.
</p>
<h2>App Start Time</h2>
<p>
  For the app start time to be recorded, you need to call the
  <code>appLoadingFinished</code> method. Make sure this method is called after
  <code>init</code>.
</p>
<pre><code class="JavaScript">//Example of appLoadingFinished<br>CountlyConfig config = CountlyConfig(SERVER_URL, APP_KEY);
Countly.initWithConfig(config ).then((value){<br>Countly.appLoadingFinished();<br>});<br></code></pre>
<p>
  This calculates and records the app launch time for performance monitoring. It
  should be called when the app is loaded and it successfully displayed its first
  user-facing view. The time passed since the app has started to launch will be
  automatically calculated and recorded for performance monitoring. Note that the
  app launch time can be recorded only once per app launch. So, the second and
  following calls to this method will be ignored.
</p>
<h2>Custom trace</h2>
<p>
  Currently, you can use custom traces to record the duration of application processes.
  At the end of them, you can also provide any additionally gathered data.
</p>
<p>
  The trace key uniquely identifies the thing you are tracking and the same name
  will be shown in the dashboard. The SDK does not support tracking multiple events
  with the same key.
</p>
<p>To start a custom trace, use:</p>
<pre><code class="JavaScript">Countly.startTrace(traceKey);</code></pre>
<p>To end a custom trace, use:</p>
<pre><code class="JavaScript">String traceKey = "Trace Key";<br>Map&lt;String, int&gt; customMetric = {<br>  "ABC": 1233,<br>  "C44C": 1337<br>};<br>Countly.endTrace(traceKey, customMetric);</code></pre>
<p>
  In this sample, a Map of integer values is provided when ending a trace. Those
  will be added to that trace in the dashboard.
</p>
<h2>Network trace</h2>
<p>
  You can use the APM to track your requests. You would record the required info
  for your selected approach of making network requests and then call this after
  your network request is done:
</p>
<pre><code class="JavaScript">Countly.recordNetworkTrace(networkTraceKey, responseCode, requestPayloadSize, responsePayloadSize, startTime, endTime);</code></pre>
<p>
  <code>networkTraceKey</code> is a unique identifier of the API endpoint you are
  targeting or just the url you are targeting, all params should be stripped. You
  would also provide the received response code, sent payload size in bytes, received
  payload size in bytes, request start time timestamp in milliseconds, and request
  end finish timestamp in milliseconds.
</p>
<h1>User consent</h1>
<p>
  For compatibility with data protection regulations, such as GDPR, the Countly
  iOS SDK allows developers to enable/disable any feature at any time depending
  on user consent. More information about GDPR
  <a href="https://blog.count.ly/countly-the-gdpr-how-worlds-leading-mobile-and-web-analytics-platform-can-help-organizations-5015042fab27">can be found here.</a>
</p>
<p>
  By default the requirement for consent is disabled. To enable it, you have to
  call <code>setRequiresConsent</code> with true, before initializing Countly.
</p>
<pre><code class="JavaScript">CountlyConfig config = CountlyConfig(SERVER_URL, APP_KEY);<br>config.setRequiresConsent(true);</code></pre>
<p>
  By default, no consent is given. That means that if no consent is enabled, Countly
  will not work and no network requests, related to features, will be sent. When
  the consent status of a feature is changed, that change will be sent to the Countly
  server.
</p>
<p>
  The Countly SDK does not persistently store the status of given consents except
  push notifications. You are expected to handle receiving consent from end-users
  using proper UIs depending on your app's context. You are also expected to store
  them either locally or remotely. Following this step, you will need to call the<code>giveConsent/giveConsentInit</code>
  method on each app launch depending on the permissions you managed to get from
  the end-users.
</p>
<p>
  The ideal location for giving consent is after <code>Countly.init</code> and
  before <code>Countly.start()</code>. Consent for features can be given and revoked
  at any time, but if it is given after<code>Countly.start()</code> , some features
  might work partially.
</p>
<p>
  If consent is removed, but the appropriate function can't be called before the
  app closes, it should be done at next app start so that any relevant server-side
  features could be disabled (like reverse geo ip for location)
</p>
<p>
  Currently, available features with consent control are as follows:
</p>
<ul>
  <li>
    sessions - tracking when, how often and how long users use your app
  </li>
  <li>events - allow sending events to the server</li>
  <li>views - allow tracking which views user visits</li>
  <li>location - allow sending location information</li>
  <li>crashes - allow tracking crashes, exceptions and errors</li>
  <li>
    attribution - allow tracking from which campaign did user come
  </li>
  <li>
    users - allow collecting/providing user information, including custom properties
  </li>
  <li>push - allow push notifications</li>
  <li>star-rating - allow sending their rating and feedback</li>
  <li>apm - allow application performance monitoring</li>
  <li>
    remote-config - allows downloading remote config values from your server
  </li>
</ul>
<h2>Giving consents</h2>
<p>
  To give consent for features, you can use the <code>setConsentEnabled</code>of
  <code>CountlyConfig</code> class or <code>giveConsent</code> after
  <code>init</code> by passing the feature names as an Array.<br>
  We recommend using the<code>setConsentEnabled</code>of
  <code>CountlyConfig</code> because some features require consents before
  <code>init</code>
</p>
<pre><code class="JavaScript">CountlyConfig config = CountlyConfig(SERVER_URL, APP_KEY);<br>config.setConsentEnabled(["location", "sessions", "attribution", "push", "events", "views", "crashes", "users", "push", "star-rating", "apm", "feedback", "remote-config"]);<br></code><code class="JavaScript">Countly.giveConsent(["events", "views", "star-rating", "crashes"]);</code></pre>
<h2>Removing consents</h2>
<p>
  If the end-user changes his/her mind about consents at a later time, you will
  need to reflect this in the Countly SDK using the <code>removeConsent</code>method:
</p>
<pre><code class="JavaScript">Countly.removeConsent(["events", "views", "star-rating", "crashes"]);</code></pre>
<h2>Giving all consents</h2>
<p>
  If you would like to give consent for all the features, you can use the
  <code>giveAllConsent</code> method:
</p>
<pre><code class="JavaScript">Countly.giveAllConsent();</code></pre>
<h2>Removing all consents</h2>
<p>
  If you would like to remove consent for all the features, you can use the
  <code>removeAllConsent</code> method:
</p>
<pre><code class="JavaScript">Countly.removeAllConsent();</code></pre>
<h1>Security and privacy</h1>
<h2>Parameter tampering protection</h2>
<p>
  You can set optional <code>salt</code> to be used for calculating checksum of
  request data, which will be sent with each request using
  <code>&amp;checksum</code> field. You need to set exactly the same
  <code>salt</code> on the Countly server. If <code>salt</code> on Countly server
  is set, all requests would be checked for the validity of
  <code>&amp;checksum</code> field before being processed.
</p>
<pre><code class="JavaScript">// sending data with salt
CountlyConfig config = CountlyConfig(SERVER_URL, APP_KEY);<br>config.setParameterTamperingProtectionSalt("salt");</code></pre>
<p>
  Make sure not to use salt on the Countly server and not on the SDK side, otherwise,
  Countly won't accept any incoming requests.
</p>
<h2>Using Proguard</h2>
<p>
  Proguard obfuscates the OpenUDID &amp; Countly Messaging classes. If you use
  OpenUDID or Countly Messaging in your application, find
  <strong class="ib cf">app/proguard-rules.pro</strong> file which sits inside
  <strong class="ib cf">/android/app/</strong> folder and adds the following lines:
</p>
<pre><code class="JavaScript">-keep class org.openudid.** { *; }
-keep class ly.count.android.sdk.** { *; }</code></pre>
<p>
  If Proguard is not already configured then first, enable shrinking and obfuscation
  in the build file. Find <strong class="ib cf">build.gradle</strong> file which
  sits inside <strong class="ib cf">/android/app/</strong> folder and adds lines
  in bold
</p>
<pre><code class="JavaScript">android {
&nbsp; &nbsp; buildTypes {
&nbsp; &nbsp; &nbsp; &nbsp; release {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Enables code shrinking, obfuscation, and optimization for only
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // your project's release build type.
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; minifyEnabled true

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Enables resource shrinking, which is performed by the
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Android Gradle plugin.
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; shrinkResources true

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Includes the default ProGuard rules files that are packaged with
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // the Android Gradle plugin. To learn more, go to the section about
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // R8 configuration files.
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; proguardFiles getDefaultProguardFile(
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'proguard-android-optimize.txt'),
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'proguard-rules.pro'
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }
...
}
</code></pre>
<p>
  Next create a configuration that will preserve the entire Flutter wrapper code.
  Create<strong class="ib cf"> /android/app/proguard-rules.pro</strong> file and
  insert inside:
</p>
<pre><code class="JavaScript">#Flutter Wrapper<br>-keep class io.flutter.app.** { *; }<br>-keep class io.flutter.plugin.**  { *; }<br>-keep class io.flutter.util.**  { *; }<br>-keep class io.flutter.view.**  { *; }<br>-keep class io.flutter.**  { *; }<br>-keep class io.flutter.plugins.**  { *; }</code></pre>
<p>
  More info related to code shrinking can be found here for
  <a href="https://flutter.dev/docs/deployment/android#shrinking-your-code-with-r8">flutter</a>
  and
  <a href="https://developer.android.com/studio/build/shrink-code#keep-code" target="_blank" rel="noopener">android</a>.
</p>
<h1>Other Features and Notes</h1>
<h2>SDK Config Parameters Explained</h2>
<p>
  To configure the SDK during init, a config object called "CountlyConfig" is used.
  Configuration is done by creating such an object and then calling it's provided
  function calls to enable functionality you need.<br>
  Here is the list of functionalities "CountlyConfig" provided:
</p>
<ul>
  <li>
    <span><strong><a href="https://support.count.ly/hc/en-us/articles/360037944212-Flutter#device-id-management" target="_self">Device Id</a> - </strong>A device ID is a unique identifier for your users. You may specify the device ID yourself or allow the SDK to generate it.<br></span>
  </li>
  <li>
    <strong><a href="https://support.count.ly/hc/en-us/articles/360037944212-Flutter#enable-logging" target="_self">Enable Logging</a> -</strong>
    To enable countly internal debugging logs<span></span>
  </li>
  <li>
    <strong><a href="https://support.count.ly/hc/en-us/articles/360037944212-Flutter#automatic-crash-handling" target="_self" rel="undefined">Enable Crash Reporting</a> -</strong>
    To enable uncaught crash reporting
  </li>
  <li>
    <strong><a href="https://support.count.ly/hc/en-us/articles/360037944212-Flutter#parameter-tampering-protection" target="_self">Salt</a> -</strong>
    Set the optional salt to be used for calculating the checksum of requested
    data which will be sent with each request<span></span>
  </li>
  <li>
    <strong><a href="https://support.count.ly/hc/en-us/articles/360037944212-Flutter#setting-an-event-queue-threshold" target="_self" rel="undefined">Event queue threshold</a> -</strong>
    Set the threshold for event grouping. Event count that is bellow the threshold
    will be sent on update ticks.<span></span>
  </li>
  <li>
    <strong>Update Session Timer -</strong> Sets the interval for the automatic
    session update calls
  </li>
  <li>
    <strong><a href="https://support.count.ly/hc/en-us/articles/360037944212-Flutter#automatic-crash-report-segmentation" target="_self">Custom Crash Segment</a> -</strong>Set
    custom crash segmentation which will be added to all recorded crashes
  </li>
  <li>
    <a href="https://support.count.ly/hc/en-us/articles/360037944212-Flutter#user-consent" target="_self"><strong>User consent</strong></a>
    - Set if consent should be required and give consents.
  </li>
  <li>
    <strong><a href="https://support.count.ly/hc/en-us/articles/360037944212-Flutter#forcing-http-post" target="_self">Forcing HTTP POST</a> -<span> </span></strong><span>When set to</span><span>&nbsp;</span><strong>true</strong><span>, all requests made to the Countly server will be done using HTTP POST. Otherwise, the SDK sends all requests using the HTTP GET method. In some cases, if the data to be sent exceeds the 1800-character limit, the SDK uses the POST method.</span><span>&nbsp;The default value is&nbsp;<strong>false</strong>. </span>
  </li>
  <li>
    <span><strong><a href="https://support.count.ly/hc/en-us/articles/360037944212-Flutter#star-rating-dialog" target="_self">Star Rating Text</a> -</strong> Set shown title, message and dismiss buttim text for the star rating dialogs.</span>
  </li>
  <li>
    <span><strong><a href="https://support.count.ly/hc/en-us/articles/360037944212-Flutter#application-performance-monitoring" target="_self">Application Performance Monitoring</a> -</strong> Enable APM features, which includes the recording of app start time.</span>
  </li>
  <li>
    <span><strong><a href="https://support.count.ly/hc/en-us/articles/360037944212-Flutter#set-user-location" target="_self">Set User Location</a> -</strong> Set user location manually instead of using Countly server to use GeoIP database to deduce a user's location.<br></span>
  </li>
  <li>
    <span><strong><a href="https://support.count.ly/hc/en-us/articles/360037944212-Flutter#setting-max-queue-size-limit" target="_self">Max Queue Size Limit</a> - </strong>Set maximum size for the request queue.</span>
  </li>
  <li>
    <span><strong><a href="https://support.count.ly/hc/en-us/articles/360037944212-Flutter#manual-sessions" target="_self">Manual Sessions</a> -</strong> To enable manual session handling</span>
  </li>
  <li>
    <strong><a href="https://support.count.ly/hc/en-us/articles/360037944212-Flutter#automatic-remote-config" target="_self">Automatic Remote Config</a> - </strong>If
    enable, will automatically download newest remote config values.
  </li>
  <li>
    <strong><a href="https://support.count.ly/hc/en-us/articles/360037944212-Flutter#direct-attribution" target="_self">Direct Attribution</a> -</strong>
    Report direct user attribution
  </li>
  <li>
    <strong><a href="https://support.count.ly/hc/en-us/articles/360037944212-Flutter#indirect-attribution" target="_self" rel="undefined">Indirect Attribution</a> -</strong>
    Report indirect user attribution
  </li>
</ul>
<h2>Attribution</h2>
<p>
  <a href="https://count.ly/attribution-analytics">Countly Attribution Analytics</a>
  allows you to measure your marketing campaign performance by attributing installs
  from specific campaigns. This feature is available for the Enterprise Edition.
</p>
<p>
  <span>There are 2 forms of attribution: direct Attribution and indirect Attribution.</span><span></span>
</p>
<h3>
  <span>Direct Attribution</span>
</h3>
<div class="callout callout--info">
  <p>
    Currently, direct attribution is only available for Android.
  </p>
</div>
<p>
  You can pass "Campaign type" and "Campaign data". The "type" determines for what
  purpose the attribution data is provided. Depending on the type, the expected
  data will differ, but usually that will be a string representation of a JSON
  object.
</p>
<p>
  <span>You can use <code>recordDirectAttribution</code> to set attribution values during initialization</span><span>.</span>
</p>
<pre><code class="JavaScript">String campaignData = 'JSON_STRING';<br>CountlyConfig config = CountlyConfig(SERVER_URL, APP_KEY);<br>config.recordDirectAttribution('CAMPAIN_TYPE', campaignData);</code><span><br></span></pre>
<p>
  You can also use <code>recordDirectAttribution</code> function to manually report
  attribution later:
</p>
<pre><code class="JavaScript">String campaignData = 'JSON_STRING';<br>Countly.recordDirectAttribution('CAMPAIN_TYPE', campaignData);</code></pre>
<p>
  Currently this feature is limited and accepts data only in a specific format
  and for a single type. That type is "countly". it would be used to record install
  attribution. The data also needs to be formatted in a specific way. Either with
  the campaign id or with the campaign id and campaign user id.
</p>
<pre><code class="JavaScript">String campaignData = '{cid:"[PROVIDED_CAMPAIGN_ID]", cuid:"[PROVIDED_CAMPAIGN_USER_ID]"}';<br>Countly.recordDirectAttribution('countly', campaignData);</code></pre>
<h3>
  <span>Indirect Attribution</span>
</h3>
<p>
  This feature would be used to report things like advertising ID's. For each platform
  those would be different values. For the most popular keys we have a class with
  predefined values to use, it is called "AttributionKey".
</p>
<p>
  <span>You can use <code>recordDirectAttribution</code> to set attribution values during initialization</span><span>.</span>
</p>
<pre><code class="JavaScript">Map&lt;String, String&gt; attributionValues = {};<br>if(Platform.isIOS){<br>  attributionValues[AttributionKey.IDFA] = 'IDFA';<br>}<br>else {<br>  attributionValues[AttributionKey.AdvertisingID] = 'AdvertisingID';<br>}<br><br>CountlyConfig config = CountlyConfig(SERVER_URL, APP_KEY);<br>config.recordIndirectAttribution(attributionValues);</code><span></span></pre>
<p>
  You can also use <code>recordIndirectAttribution</code> function to manually
  report attribution later
</p>
<pre><code class="JavaScript">Map&lt;String, String&gt; attributionValues = {};<br>if(Platform.isIOS){<br>  attributionValues[AttributionKey.IDFA] = 'IDFA';<br>}<br>else {<br>  attributionValues[AttributionKey.AdvertisingID] = 'AdvertisingID';<br>}<br><br>Countly.recordIndirectAttribution(attributionValues);</code></pre>
<p>
  In case you would be accessing IDFA for ios, for iOS 14+ due to Apple changes
  regarding Application Tracking, you need to ask the user for permission to track
  the Application.
</p>
<h2>Forcing HTTP POST</h2>
<p>
  If the data sent to the server is short enough, the SDK will use HTTP GET requests.
  In case you want an override so that HTTP POST is used in all cases, call the
  <code>setHttpPostForced</code> function after you called <code>init</code>. You
  can use the same function later in the app's life cycle to disable the override.
  This function has to be called every time the app starts.
</p>
<pre><code class="JavaScript"> CountlyConfig config = CountlyConfig(SERVER_URL, APP_KEY);<br>config.setHttpPostForced(true); // default is false</code></pre>
<h2>Interacting with the internal request queue</h2>
<p>
  When recording events or activities, the requests don't always get sent immediately.
  Events get grouped together. All the requests contain the same app key which
  is provided in the <code>init</code> function.
</p>
<p>
  There are two ways to interact with the app key in the request queue at the moment.
</p>
<p>
  1. You can replace all requests with a different app key with the current app
  key:
</p>
<pre><code class="JavaScript">//Replaces all requests with a different app key with the current app key.
Countly.replaceAllAppKeysInQueueWithCurrentAppKey();</code></pre>
<p>
  In the request queue, if there are any requests whose app key is different than
  the current app key, these requests app key will be replaced with the current
  app key. 2. You can remove all requests with a different app key in the request
  queue:
</p>
<pre><code class="JavaScript">//Removes all requests with a different app key in request queue.
Countly.removeDifferentAppKeysFromQueue();</code></pre>
<p>
  In the request queue, if there are any requests whose app key is different than
  the current app key, these requests will be removed from the request queue.
</p>
<h2>Setting an event queue threshold</h2>
<p>
  Events get grouped together and are sent either every minute or after the unsent
  event count reaches a threshold. By default it is 10. If you would like to change
  this, call:
</p>
<pre><code class="JavaScript">CountlyConfig config = CountlyConfig(SERVER_URL, APP_KEY);<br>config.setEventQueueSizeToSend(6);</code></pre>
<h2>Setting max queue size limit</h2>
<p>
  <span>You can specify the max request queue size by calling <code>setMaxRequestQueueSize</code></span><span> of the <code>CountlyConfig</code></span><span> object before starting Countly. It is used to limit the number of requests stored when there is no connection to your Countly Server. </span><span>If the max queue size limit</span><span>&nbsp;is not explicitly set, the default setting will be at&nbsp;</span><strong>1000</strong><span>.</span>
</p>
<pre><code class="JavaScript">CountlyConfig config = CountlyConfig(SERVER_URL, APP_KEY);<br>config.setMaxRequestQueueSize(2500);</code><span><br></span></pre>
<h2>Checking if the SDK has been initialized</h2>
<p>
  In case you would like to check if init has been called, you may use the following
  function:
</p>
<pre><code class="JavaScript">Countly.isInitialized();</code></pre>
